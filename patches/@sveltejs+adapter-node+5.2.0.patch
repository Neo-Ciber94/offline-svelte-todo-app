diff --git a/node_modules/@sveltejs/adapter-node/.17efdeeecbad3f73-00000003.shims.js b/node_modules/@sveltejs/adapter-node/.17efdeeecbad3f73-00000003.shims.js
new file mode 100644
index 0000000..9cddad8
--- /dev/null
+++ b/node_modules/@sveltejs/adapter-node/.17efdeeecbad3f73-00000003.shims.js
@@ -0,0 +1,32 @@
+import buffer from 'node:buffer';
+import { webcrypto } from 'node:crypto';
+
+// `buffer.File` was added in Node 18.13.0 while the `File` global was added in Node 20.0.0
+const File = /** @type {import('node:buffer') & { File?: File}} */ (buffer).File;
+
+/** @type {Record<string, any>} */
+const globals = {
+	crypto: webcrypto,
+	File
+};
+
+// exported for dev/preview and node environments
+/**
+ * Make various web APIs available as globals:
+ * - `crypto`
+ * - `File`
+ */
+function installPolyfills() {
+	for (const name in globals) {
+		if (name in globalThis) continue;
+
+		Object.defineProperty(globalThis, name, {
+			enumerable: true,
+			configurable: true,
+			writable: true,
+			value: globals[name]
+		});
+	}
+}
+
+installPolyfills();
diff --git a/node_modules/@sveltejs/adapter-node/.17fffeef7a9df9ff-00000002.index.js b/node_modules/@sveltejs/adapter-node/.17fffeef7a9df9ff-00000002.index.js
new file mode 100644
index 0000000..7b0ab9c
--- /dev/null
+++ b/node_modules/@sveltejs/adapter-node/.17fffeef7a9df9ff-00000002.index.js
@@ -0,0 +1,332 @@
+import { handler } from 'HANDLER';
+import { env } from 'ENV';
+import http from 'http';
+import * as qs from 'querystring';
+
+/**
+ * @param {string|RegExp} input The route pattern
+ * @param {boolean} [loose] Allow open-ended matching. Ignored with `RegExp` input.
+ */
+function parse$1(input, loose) {
+	if (input instanceof RegExp) return { keys:false, pattern:input };
+	var c, o, tmp, ext, keys=[], pattern='', arr = input.split('/');
+	arr[0] || arr.shift();
+
+	while (tmp = arr.shift()) {
+		c = tmp[0];
+		if (c === '*') {
+			keys.push(c);
+			pattern += tmp[1] === '?' ? '(?:/(.*))?' : '/(.*)';
+		} else if (c === ':') {
+			o = tmp.indexOf('?', 1);
+			ext = tmp.indexOf('.', 1);
+			keys.push( tmp.substring(1, !!~o ? o : !!~ext ? ext : tmp.length) );
+			pattern += !!~o && !~ext ? '(?:/([^/]+?))?' : '/([^/]+?)';
+			if (!!~ext) pattern += (!!~o ? '?' : '') + '\\' + tmp.substring(ext);
+		} else {
+			pattern += '/' + tmp;
+		}
+	}
+
+	return {
+		keys: keys,
+		pattern: new RegExp('^' + pattern + (loose ? '(?=$|\/)' : '\/?$'), 'i')
+	};
+}
+
+const MAP = {
+	"": 0,
+	GET: 1,
+	HEAD: 2,
+	PATCH: 3,
+	OPTIONS: 4,
+	CONNECT: 5,
+	DELETE: 6,
+	TRACE: 7,
+	POST: 8,
+	PUT: 9,
+};
+
+class Trouter {
+	constructor() {
+		this.routes = [];
+
+		this.all = this.add.bind(this, '');
+		this.get = this.add.bind(this, 'GET');
+		this.head = this.add.bind(this, 'HEAD');
+		this.patch = this.add.bind(this, 'PATCH');
+		this.options = this.add.bind(this, 'OPTIONS');
+		this.connect = this.add.bind(this, 'CONNECT');
+		this.delete = this.add.bind(this, 'DELETE');
+		this.trace = this.add.bind(this, 'TRACE');
+		this.post = this.add.bind(this, 'POST');
+		this.put = this.add.bind(this, 'PUT');
+	}
+
+	use(route, ...fns) {
+		let handlers = [].concat.apply([], fns);
+		let { keys, pattern } = parse$1(route, true);
+		this.routes.push({ keys, pattern, method: '', handlers, midx: MAP[''] });
+		return this;
+	}
+
+	add(method, route, ...fns) {
+		let { keys, pattern } = parse$1(route);
+		let handlers = [].concat.apply([], fns);
+		this.routes.push({ keys, pattern, method, handlers, midx: MAP[method] });
+		return this;
+	}
+
+	find(method, url) {
+		let midx = MAP[method];
+		let isHEAD = (midx === 2);
+		let i=0, j=0, k, tmp, arr=this.routes;
+		let matches=[], params={}, handlers=[];
+		for (; i < arr.length; i++) {
+			tmp = arr[i];
+			if (tmp.midx === midx  || tmp.midx === 0 || (isHEAD && tmp.midx===1) ) {
+				if (tmp.keys === false) {
+					matches = tmp.pattern.exec(url);
+					if (matches === null) continue;
+					if (matches.groups !== void 0) for (k in matches.groups) params[k]=matches.groups[k];
+					tmp.handlers.length > 1 ? (handlers=handlers.concat(tmp.handlers)) : handlers.push(tmp.handlers[0]);
+				} else if (tmp.keys.length > 0) {
+					matches = tmp.pattern.exec(url);
+					if (matches === null) continue;
+					for (j=0; j < tmp.keys.length;) params[tmp.keys[j]]=matches[++j];
+					tmp.handlers.length > 1 ? (handlers=handlers.concat(tmp.handlers)) : handlers.push(tmp.handlers[0]);
+				} else if (tmp.pattern.test(url)) {
+					tmp.handlers.length > 1 ? (handlers=handlers.concat(tmp.handlers)) : handlers.push(tmp.handlers[0]);
+				}
+			} // else not a match
+		}
+
+		return { params, handlers };
+	}
+}
+
+/**
+ * @typedef ParsedURL
+ * @type {import('.').ParsedURL}
+ */
+
+/**
+ * @typedef Request
+ * @property {string} url
+ * @property {ParsedURL} _parsedUrl
+ */
+
+/**
+ * @param {Request} req
+ * @returns {ParsedURL|void}
+ */
+function parse(req) {
+	let raw = req.url;
+	if (raw == null) return;
+
+	let prev = req._parsedUrl;
+	if (prev && prev.raw === raw) return prev;
+
+	let pathname=raw, search='', query;
+
+	if (raw.length > 1) {
+		let idx = raw.indexOf('?', 1);
+
+		if (idx !== -1) {
+			search = raw.substring(idx);
+			pathname = raw.substring(0, idx);
+			if (search.length > 1) {
+				query = qs.parse(search.substring(1));
+			}
+		}
+	}
+
+	return req._parsedUrl = { pathname, search, query, raw };
+}
+
+function onError(err, req, res) {
+	let code = typeof err.status === 'number' && err.status;
+	code = res.statusCode = (code && code >= 100 ? code : 500);
+	if (typeof err === 'string' || Buffer.isBuffer(err)) res.end(err);
+	else res.end(err.message || http.STATUS_CODES[code]);
+}
+
+const mount = fn => fn instanceof Polka ? fn.attach : fn;
+
+class Polka extends Trouter {
+	constructor(opts={}) {
+		super();
+		this.parse = parse;
+		this.server = opts.server;
+		this.handler = this.handler.bind(this);
+		this.onError = opts.onError || onError; // catch-all handler
+		this.onNoMatch = opts.onNoMatch || this.onError.bind(null, { status: 404 });
+		this.attach = (req, res) => setImmediate(this.handler, req, res);
+	}
+
+	use(base, ...fns) {
+		if (base === '/') {
+			super.use(base, fns.map(mount));
+		} else if (typeof base === 'function' || base instanceof Polka) {
+			super.use('/', [base, ...fns].map(mount));
+		} else {
+			super.use(base,
+				(req, _, next) => {
+					if (typeof base === 'string') {
+						let len = base.length;
+						base.startsWith('/') || len++;
+						req.url = req.url.substring(len) || '/';
+						req.path = req.path.substring(len) || '/';
+					} else {
+						req.url = req.url.replace(base, '') || '/';
+						req.path = req.path.replace(base, '') || '/';
+					}
+					if (req.url.charAt(0) !== '/') {
+						req.url = '/' + req.url;
+					}
+					next();
+				},
+				fns.map(mount),
+				(req, _, next) => {
+					req.path = req._parsedUrl.pathname;
+					req.url = req.path + req._parsedUrl.search;
+					next();
+				}
+			);
+		}
+		return this; // chainable
+	}
+
+	listen() {
+		(this.server = this.server || http.createServer()).on('request', this.attach);
+		this.server.listen.apply(this.server, arguments);
+		return this;
+	}
+
+	handler(req, res, next) {
+		let info = this.parse(req), path = info.pathname;
+		let obj = this.find(req.method, req.path=path);
+
+		req.url = path + info.search;
+		req.originalUrl = req.originalUrl || req.url;
+		req.query = info.query || {};
+		req.search = info.search;
+		req.params = obj.params;
+
+		if (path.length > 1 && path.indexOf('%', 1) !== -1) {
+			for (let k in req.params) {
+				try { req.params[k] = decodeURIComponent(req.params[k]); }
+				catch (e) { /* malform uri segment */ }
+			}
+		}
+
+		let i=0, arr=obj.handlers.concat(this.onNoMatch), len=arr.length;
+		let loop = async () => res.finished || (i < len) && arr[i++](req, res, next);
+		(next = next || (err => err ? this.onError(err, req, res, next) : loop().catch(next)))(); // init
+	}
+}
+
+function polka (opts) {
+	return new Polka(opts);
+}
+
+const path = env('SOCKET_PATH', false);
+const host = env('HOST', '0.0.0.0');
+const port = env('PORT', !path && '3000');
+
+const shutdown_timeout = parseInt(env('SHUTDOWN_TIMEOUT', '30'));
+const idle_timeout = parseInt(env('IDLE_TIMEOUT', '0'));
+const listen_pid = parseInt(env('LISTEN_PID', '0'));
+const listen_fds = parseInt(env('LISTEN_FDS', '0'));
+// https://www.freedesktop.org/software/systemd/man/latest/sd_listen_fds.html
+const SD_LISTEN_FDS_START = 3;
+
+if (listen_pid !== 0 && listen_pid !== process.pid) {
+	throw new Error(`received LISTEN_PID ${listen_pid} but current process id is ${process.pid}`);
+}
+if (listen_fds > 1) {
+	throw new Error(
+		`only one socket is allowed for socket activation, but LISTEN_FDS was set to ${listen_fds}`
+	);
+}
+
+const socket_activation = listen_pid === process.pid && listen_fds === 1;
+
+let requests = 0;
+/** @type {NodeJS.Timeout | void} */
+let shutdown_timeout_id;
+/** @type {NodeJS.Timeout | void} */
+let idle_timeout_id;
+
+const server = polka().use(handler);
+
+if (socket_activation) {
+	server.listen({ fd: SD_LISTEN_FDS_START }, () => {
+		console.log(`Listening on file descriptor ${SD_LISTEN_FDS_START}`);
+	});
+} else {
+	server.listen({ path, host, port }, () => {
+		console.log(`Listening on ${path ? path : host + ':' + port}`);
+	});
+}
+
+/** @param {'SIGINT' | 'SIGTERM' | 'IDLE'} reason */
+function graceful_shutdown(reason) {
+	if (shutdown_timeout_id) return;
+
+	// If a connection was opened with a keep-alive header close() will wait for the connection to
+	// time out rather than close it even if it is not handling any requests, so call this first
+	// @ts-expect-error this was added in 18.2.0 but is not reflected in the types
+	server.server.closeIdleConnections();
+
+	server.server.close((error) => {
+		// occurs if the server is already closed
+		if (error) return;
+
+		if (shutdown_timeout_id) {
+			clearTimeout(shutdown_timeout_id);
+		}
+		if (idle_timeout_id) {
+			clearTimeout(idle_timeout_id);
+		}
+
+		// @ts-expect-error custom events cannot be typed
+		process.emit('sveltekit:shutdown', reason);
+	});
+
+	shutdown_timeout_id = setTimeout(
+		// @ts-expect-error this was added in 18.2.0 but is not reflected in the types
+		() => server.server.closeAllConnections(),
+		shutdown_timeout * 1000
+	);
+}
+
+server.server.on(
+	'request',
+	/** @param {import('node:http').IncomingMessage} req */
+	(req) => {
+		requests++;
+
+		if (socket_activation && idle_timeout_id) {
+			idle_timeout_id = clearTimeout(idle_timeout_id);
+		}
+
+		req.on('close', () => {
+			requests--;
+
+			if (shutdown_timeout_id) {
+				// close connections as soon as they become idle, so they don't accept new requests
+				// @ts-expect-error this was added in 18.2.0 but is not reflected in the types
+				server.server.closeIdleConnections();
+			}
+			if (requests === 0 && socket_activation && idle_timeout) {
+				idle_timeout_id = setTimeout(() => graceful_shutdown('IDLE'), idle_timeout * 1000);
+			}
+		});
+	}
+);
+
+process.on('SIGTERM', graceful_shutdown);
+process.on('SIGINT', graceful_shutdown);
+
+export { host, path, port, server };
diff --git a/node_modules/@sveltejs/adapter-node/.1feffdfb7bfdbadb-00000007.package.json b/node_modules/@sveltejs/adapter-node/.1feffdfb7bfdbadb-00000007.package.json
new file mode 100644
index 0000000..e0cb434
--- /dev/null
+++ b/node_modules/@sveltejs/adapter-node/.1feffdfb7bfdbadb-00000007.package.json
@@ -0,0 +1,61 @@
+{
+  "name": "@sveltejs/adapter-node",
+  "version": "5.2.0",
+  "description": "Adapter for SvelteKit apps that generates a standalone Node server",
+  "keywords": [
+    "adapter",
+    "deploy",
+    "hosting",
+    "node.js",
+    "svelte",
+    "sveltekit"
+  ],
+  "repository": {
+    "type": "git",
+    "url": "https://github.com/sveltejs/kit",
+    "directory": "packages/adapter-node"
+  },
+  "license": "MIT",
+  "homepage": "https://kit.svelte.dev",
+  "type": "module",
+  "exports": {
+    ".": {
+      "types": "./index.d.ts",
+      "import": "./index.js"
+    },
+    "./package.json": "./package.json"
+  },
+  "types": "index.d.ts",
+  "files": [
+    "files",
+    "index.js",
+    "index.d.ts"
+  ],
+  "devDependencies": {
+    "@polka/url": "1.0.0-next.25",
+    "@sveltejs/vite-plugin-svelte": "^3.0.1",
+    "@types/node": "^18.19.3",
+    "polka": "1.0.0-next.25",
+    "sirv": "^2.0.4",
+    "typescript": "^5.3.3",
+    "vitest": "^1.6.0",
+    "@sveltejs/kit": "^2.5.17"
+  },
+  "dependencies": {
+    "@rollup/plugin-commonjs": "^26.0.1",
+    "@rollup/plugin-json": "^6.1.0",
+    "@rollup/plugin-node-resolve": "^15.2.3",
+    "rollup": "^4.9.5"
+  },
+  "peerDependencies": {
+    "@sveltejs/kit": "^2.4.0"
+  },
+  "scripts": {
+    "dev": "node -e \"fs.rmSync('files', { force: true, recursive: true })\" && rollup -cw",
+    "build": "node -e \"fs.rmSync('files', { force: true, recursive: true })\" && rollup -c",
+    "test": "echo \"tests temporarily disabled\" # vitest run",
+    "check": "tsc",
+    "lint": "prettier --check .",
+    "format": "pnpm lint --write"
+  }
+}
\ No newline at end of file
diff --git a/node_modules/@sveltejs/adapter-node/.37efdffbd1a09bf9-00000001.handler.js b/node_modules/@sveltejs/adapter-node/.37efdffbd1a09bf9-00000001.handler.js
new file mode 100644
index 0000000..40d5245
--- /dev/null
+++ b/node_modules/@sveltejs/adapter-node/.37efdffbd1a09bf9-00000001.handler.js
@@ -0,0 +1,1353 @@
+import 'SHIMS';
+import fs$1, { createReadStream } from 'node:fs';
+import path from 'node:path';
+import * as fs from 'fs';
+import { readdirSync, statSync } from 'fs';
+import { resolve, join, normalize } from 'path';
+import * as qs from 'querystring';
+import { fileURLToPath } from 'node:url';
+import { Readable } from 'node:stream';
+import { Server } from 'SERVER';
+import { manifest, prerendered, base } from 'MANIFEST';
+import { env } from 'ENV';
+
+function totalist(dir, callback, pre='') {
+	dir = resolve('.', dir);
+	let arr = readdirSync(dir);
+	let i=0, abs, stats;
+	for (; i < arr.length; i++) {
+		abs = join(dir, arr[i]);
+		stats = statSync(abs);
+		stats.isDirectory()
+			? totalist(abs, callback, join(pre, arr[i]))
+			: callback(join(pre, arr[i]), abs, stats);
+	}
+}
+
+/**
+ * @typedef ParsedURL
+ * @type {import('.').ParsedURL}
+ */
+
+/**
+ * @typedef Request
+ * @property {string} url
+ * @property {ParsedURL} _parsedUrl
+ */
+
+/**
+ * @param {Request} req
+ * @returns {ParsedURL|void}
+ */
+function parse$1(req) {
+	let raw = req.url;
+	if (raw == null) return;
+
+	let prev = req._parsedUrl;
+	if (prev && prev.raw === raw) return prev;
+
+	let pathname=raw, search='', query;
+
+	if (raw.length > 1) {
+		let idx = raw.indexOf('?', 1);
+
+		if (idx !== -1) {
+			search = raw.substring(idx);
+			pathname = raw.substring(0, idx);
+			if (search.length > 1) {
+				query = qs.parse(search.substring(1));
+			}
+		}
+	}
+
+	return req._parsedUrl = { pathname, search, query, raw };
+}
+
+const mimes = {
+  "3g2": "video/3gpp2",
+  "3gp": "video/3gpp",
+  "3gpp": "video/3gpp",
+  "3mf": "model/3mf",
+  "aac": "audio/aac",
+  "ac": "application/pkix-attr-cert",
+  "adp": "audio/adpcm",
+  "adts": "audio/aac",
+  "ai": "application/postscript",
+  "aml": "application/automationml-aml+xml",
+  "amlx": "application/automationml-amlx+zip",
+  "amr": "audio/amr",
+  "apng": "image/apng",
+  "appcache": "text/cache-manifest",
+  "appinstaller": "application/appinstaller",
+  "appx": "application/appx",
+  "appxbundle": "application/appxbundle",
+  "asc": "application/pgp-keys",
+  "atom": "application/atom+xml",
+  "atomcat": "application/atomcat+xml",
+  "atomdeleted": "application/atomdeleted+xml",
+  "atomsvc": "application/atomsvc+xml",
+  "au": "audio/basic",
+  "avci": "image/avci",
+  "avcs": "image/avcs",
+  "avif": "image/avif",
+  "aw": "application/applixware",
+  "bdoc": "application/bdoc",
+  "bin": "application/octet-stream",
+  "bmp": "image/bmp",
+  "bpk": "application/octet-stream",
+  "btf": "image/prs.btif",
+  "btif": "image/prs.btif",
+  "buffer": "application/octet-stream",
+  "ccxml": "application/ccxml+xml",
+  "cdfx": "application/cdfx+xml",
+  "cdmia": "application/cdmi-capability",
+  "cdmic": "application/cdmi-container",
+  "cdmid": "application/cdmi-domain",
+  "cdmio": "application/cdmi-object",
+  "cdmiq": "application/cdmi-queue",
+  "cer": "application/pkix-cert",
+  "cgm": "image/cgm",
+  "cjs": "application/node",
+  "class": "application/java-vm",
+  "coffee": "text/coffeescript",
+  "conf": "text/plain",
+  "cpl": "application/cpl+xml",
+  "cpt": "application/mac-compactpro",
+  "crl": "application/pkix-crl",
+  "css": "text/css",
+  "csv": "text/csv",
+  "cu": "application/cu-seeme",
+  "cwl": "application/cwl",
+  "cww": "application/prs.cww",
+  "davmount": "application/davmount+xml",
+  "dbk": "application/docbook+xml",
+  "deb": "application/octet-stream",
+  "def": "text/plain",
+  "deploy": "application/octet-stream",
+  "dib": "image/bmp",
+  "disposition-notification": "message/disposition-notification",
+  "dist": "application/octet-stream",
+  "distz": "application/octet-stream",
+  "dll": "application/octet-stream",
+  "dmg": "application/octet-stream",
+  "dms": "application/octet-stream",
+  "doc": "application/msword",
+  "dot": "application/msword",
+  "dpx": "image/dpx",
+  "drle": "image/dicom-rle",
+  "dsc": "text/prs.lines.tag",
+  "dssc": "application/dssc+der",
+  "dtd": "application/xml-dtd",
+  "dump": "application/octet-stream",
+  "dwd": "application/atsc-dwd+xml",
+  "ear": "application/java-archive",
+  "ecma": "application/ecmascript",
+  "elc": "application/octet-stream",
+  "emf": "image/emf",
+  "eml": "message/rfc822",
+  "emma": "application/emma+xml",
+  "emotionml": "application/emotionml+xml",
+  "eps": "application/postscript",
+  "epub": "application/epub+zip",
+  "exe": "application/octet-stream",
+  "exi": "application/exi",
+  "exp": "application/express",
+  "exr": "image/aces",
+  "ez": "application/andrew-inset",
+  "fdf": "application/fdf",
+  "fdt": "application/fdt+xml",
+  "fits": "image/fits",
+  "g3": "image/g3fax",
+  "gbr": "application/rpki-ghostbusters",
+  "geojson": "application/geo+json",
+  "gif": "image/gif",
+  "glb": "model/gltf-binary",
+  "gltf": "model/gltf+json",
+  "gml": "application/gml+xml",
+  "gpx": "application/gpx+xml",
+  "gram": "application/srgs",
+  "grxml": "application/srgs+xml",
+  "gxf": "application/gxf",
+  "gz": "application/gzip",
+  "h261": "video/h261",
+  "h263": "video/h263",
+  "h264": "video/h264",
+  "heic": "image/heic",
+  "heics": "image/heic-sequence",
+  "heif": "image/heif",
+  "heifs": "image/heif-sequence",
+  "hej2": "image/hej2k",
+  "held": "application/atsc-held+xml",
+  "hjson": "application/hjson",
+  "hlp": "application/winhlp",
+  "hqx": "application/mac-binhex40",
+  "hsj2": "image/hsj2",
+  "htm": "text/html",
+  "html": "text/html",
+  "ics": "text/calendar",
+  "ief": "image/ief",
+  "ifb": "text/calendar",
+  "iges": "model/iges",
+  "igs": "model/iges",
+  "img": "application/octet-stream",
+  "in": "text/plain",
+  "ini": "text/plain",
+  "ink": "application/inkml+xml",
+  "inkml": "application/inkml+xml",
+  "ipfix": "application/ipfix",
+  "iso": "application/octet-stream",
+  "its": "application/its+xml",
+  "jade": "text/jade",
+  "jar": "application/java-archive",
+  "jhc": "image/jphc",
+  "jls": "image/jls",
+  "jp2": "image/jp2",
+  "jpe": "image/jpeg",
+  "jpeg": "image/jpeg",
+  "jpf": "image/jpx",
+  "jpg": "image/jpeg",
+  "jpg2": "image/jp2",
+  "jpgm": "image/jpm",
+  "jpgv": "video/jpeg",
+  "jph": "image/jph",
+  "jpm": "image/jpm",
+  "jpx": "image/jpx",
+  "js": "text/javascript",
+  "json": "application/json",
+  "json5": "application/json5",
+  "jsonld": "application/ld+json",
+  "jsonml": "application/jsonml+json",
+  "jsx": "text/jsx",
+  "jt": "model/jt",
+  "jxr": "image/jxr",
+  "jxra": "image/jxra",
+  "jxrs": "image/jxrs",
+  "jxs": "image/jxs",
+  "jxsc": "image/jxsc",
+  "jxsi": "image/jxsi",
+  "jxss": "image/jxss",
+  "kar": "audio/midi",
+  "ktx": "image/ktx",
+  "ktx2": "image/ktx2",
+  "less": "text/less",
+  "lgr": "application/lgr+xml",
+  "list": "text/plain",
+  "litcoffee": "text/coffeescript",
+  "log": "text/plain",
+  "lostxml": "application/lost+xml",
+  "lrf": "application/octet-stream",
+  "m1v": "video/mpeg",
+  "m21": "application/mp21",
+  "m2a": "audio/mpeg",
+  "m2v": "video/mpeg",
+  "m3a": "audio/mpeg",
+  "m4a": "audio/mp4",
+  "m4p": "application/mp4",
+  "m4s": "video/iso.segment",
+  "ma": "application/mathematica",
+  "mads": "application/mads+xml",
+  "maei": "application/mmt-aei+xml",
+  "man": "text/troff",
+  "manifest": "text/cache-manifest",
+  "map": "application/json",
+  "mar": "application/octet-stream",
+  "markdown": "text/markdown",
+  "mathml": "application/mathml+xml",
+  "mb": "application/mathematica",
+  "mbox": "application/mbox",
+  "md": "text/markdown",
+  "mdx": "text/mdx",
+  "me": "text/troff",
+  "mesh": "model/mesh",
+  "meta4": "application/metalink4+xml",
+  "metalink": "application/metalink+xml",
+  "mets": "application/mets+xml",
+  "mft": "application/rpki-manifest",
+  "mid": "audio/midi",
+  "midi": "audio/midi",
+  "mime": "message/rfc822",
+  "mj2": "video/mj2",
+  "mjp2": "video/mj2",
+  "mjs": "text/javascript",
+  "mml": "text/mathml",
+  "mods": "application/mods+xml",
+  "mov": "video/quicktime",
+  "mp2": "audio/mpeg",
+  "mp21": "application/mp21",
+  "mp2a": "audio/mpeg",
+  "mp3": "audio/mpeg",
+  "mp4": "video/mp4",
+  "mp4a": "audio/mp4",
+  "mp4s": "application/mp4",
+  "mp4v": "video/mp4",
+  "mpd": "application/dash+xml",
+  "mpe": "video/mpeg",
+  "mpeg": "video/mpeg",
+  "mpf": "application/media-policy-dataset+xml",
+  "mpg": "video/mpeg",
+  "mpg4": "video/mp4",
+  "mpga": "audio/mpeg",
+  "mpp": "application/dash-patch+xml",
+  "mrc": "application/marc",
+  "mrcx": "application/marcxml+xml",
+  "ms": "text/troff",
+  "mscml": "application/mediaservercontrol+xml",
+  "msh": "model/mesh",
+  "msi": "application/octet-stream",
+  "msix": "application/msix",
+  "msixbundle": "application/msixbundle",
+  "msm": "application/octet-stream",
+  "msp": "application/octet-stream",
+  "mtl": "model/mtl",
+  "musd": "application/mmt-usd+xml",
+  "mxf": "application/mxf",
+  "mxmf": "audio/mobile-xmf",
+  "mxml": "application/xv+xml",
+  "n3": "text/n3",
+  "nb": "application/mathematica",
+  "nq": "application/n-quads",
+  "nt": "application/n-triples",
+  "obj": "model/obj",
+  "oda": "application/oda",
+  "oga": "audio/ogg",
+  "ogg": "audio/ogg",
+  "ogv": "video/ogg",
+  "ogx": "application/ogg",
+  "omdoc": "application/omdoc+xml",
+  "onepkg": "application/onenote",
+  "onetmp": "application/onenote",
+  "onetoc": "application/onenote",
+  "onetoc2": "application/onenote",
+  "opf": "application/oebps-package+xml",
+  "opus": "audio/ogg",
+  "otf": "font/otf",
+  "owl": "application/rdf+xml",
+  "oxps": "application/oxps",
+  "p10": "application/pkcs10",
+  "p7c": "application/pkcs7-mime",
+  "p7m": "application/pkcs7-mime",
+  "p7s": "application/pkcs7-signature",
+  "p8": "application/pkcs8",
+  "pdf": "application/pdf",
+  "pfr": "application/font-tdpfr",
+  "pgp": "application/pgp-encrypted",
+  "pkg": "application/octet-stream",
+  "pki": "application/pkixcmp",
+  "pkipath": "application/pkix-pkipath",
+  "pls": "application/pls+xml",
+  "png": "image/png",
+  "prc": "model/prc",
+  "prf": "application/pics-rules",
+  "provx": "application/provenance+xml",
+  "ps": "application/postscript",
+  "pskcxml": "application/pskc+xml",
+  "pti": "image/prs.pti",
+  "qt": "video/quicktime",
+  "raml": "application/raml+yaml",
+  "rapd": "application/route-apd+xml",
+  "rdf": "application/rdf+xml",
+  "relo": "application/p2p-overlay+xml",
+  "rif": "application/reginfo+xml",
+  "rl": "application/resource-lists+xml",
+  "rld": "application/resource-lists-diff+xml",
+  "rmi": "audio/midi",
+  "rnc": "application/relax-ng-compact-syntax",
+  "rng": "application/xml",
+  "roa": "application/rpki-roa",
+  "roff": "text/troff",
+  "rq": "application/sparql-query",
+  "rs": "application/rls-services+xml",
+  "rsat": "application/atsc-rsat+xml",
+  "rsd": "application/rsd+xml",
+  "rsheet": "application/urc-ressheet+xml",
+  "rss": "application/rss+xml",
+  "rtf": "text/rtf",
+  "rtx": "text/richtext",
+  "rusd": "application/route-usd+xml",
+  "s3m": "audio/s3m",
+  "sbml": "application/sbml+xml",
+  "scq": "application/scvp-cv-request",
+  "scs": "application/scvp-cv-response",
+  "sdp": "application/sdp",
+  "senmlx": "application/senml+xml",
+  "sensmlx": "application/sensml+xml",
+  "ser": "application/java-serialized-object",
+  "setpay": "application/set-payment-initiation",
+  "setreg": "application/set-registration-initiation",
+  "sgi": "image/sgi",
+  "sgm": "text/sgml",
+  "sgml": "text/sgml",
+  "shex": "text/shex",
+  "shf": "application/shf+xml",
+  "shtml": "text/html",
+  "sieve": "application/sieve",
+  "sig": "application/pgp-signature",
+  "sil": "audio/silk",
+  "silo": "model/mesh",
+  "siv": "application/sieve",
+  "slim": "text/slim",
+  "slm": "text/slim",
+  "sls": "application/route-s-tsid+xml",
+  "smi": "application/smil+xml",
+  "smil": "application/smil+xml",
+  "snd": "audio/basic",
+  "so": "application/octet-stream",
+  "spdx": "text/spdx",
+  "spp": "application/scvp-vp-response",
+  "spq": "application/scvp-vp-request",
+  "spx": "audio/ogg",
+  "sql": "application/sql",
+  "sru": "application/sru+xml",
+  "srx": "application/sparql-results+xml",
+  "ssdl": "application/ssdl+xml",
+  "ssml": "application/ssml+xml",
+  "stk": "application/hyperstudio",
+  "stl": "model/stl",
+  "stpx": "model/step+xml",
+  "stpxz": "model/step-xml+zip",
+  "stpz": "model/step+zip",
+  "styl": "text/stylus",
+  "stylus": "text/stylus",
+  "svg": "image/svg+xml",
+  "svgz": "image/svg+xml",
+  "swidtag": "application/swid+xml",
+  "t": "text/troff",
+  "t38": "image/t38",
+  "td": "application/urc-targetdesc+xml",
+  "tei": "application/tei+xml",
+  "teicorpus": "application/tei+xml",
+  "text": "text/plain",
+  "tfi": "application/thraud+xml",
+  "tfx": "image/tiff-fx",
+  "tif": "image/tiff",
+  "tiff": "image/tiff",
+  "toml": "application/toml",
+  "tr": "text/troff",
+  "trig": "application/trig",
+  "ts": "video/mp2t",
+  "tsd": "application/timestamped-data",
+  "tsv": "text/tab-separated-values",
+  "ttc": "font/collection",
+  "ttf": "font/ttf",
+  "ttl": "text/turtle",
+  "ttml": "application/ttml+xml",
+  "txt": "text/plain",
+  "u3d": "model/u3d",
+  "u8dsn": "message/global-delivery-status",
+  "u8hdr": "message/global-headers",
+  "u8mdn": "message/global-disposition-notification",
+  "u8msg": "message/global",
+  "ubj": "application/ubjson",
+  "uri": "text/uri-list",
+  "uris": "text/uri-list",
+  "urls": "text/uri-list",
+  "vcard": "text/vcard",
+  "vrml": "model/vrml",
+  "vtt": "text/vtt",
+  "vxml": "application/voicexml+xml",
+  "war": "application/java-archive",
+  "wasm": "application/wasm",
+  "wav": "audio/wav",
+  "weba": "audio/webm",
+  "webm": "video/webm",
+  "webmanifest": "application/manifest+json",
+  "webp": "image/webp",
+  "wgsl": "text/wgsl",
+  "wgt": "application/widget",
+  "wif": "application/watcherinfo+xml",
+  "wmf": "image/wmf",
+  "woff": "font/woff",
+  "woff2": "font/woff2",
+  "wrl": "model/vrml",
+  "wsdl": "application/wsdl+xml",
+  "wspolicy": "application/wspolicy+xml",
+  "x3d": "model/x3d+xml",
+  "x3db": "model/x3d+fastinfoset",
+  "x3dbz": "model/x3d+binary",
+  "x3dv": "model/x3d-vrml",
+  "x3dvz": "model/x3d+vrml",
+  "x3dz": "model/x3d+xml",
+  "xaml": "application/xaml+xml",
+  "xav": "application/xcap-att+xml",
+  "xca": "application/xcap-caps+xml",
+  "xcs": "application/calendar+xml",
+  "xdf": "application/xcap-diff+xml",
+  "xdssc": "application/dssc+xml",
+  "xel": "application/xcap-el+xml",
+  "xenc": "application/xenc+xml",
+  "xer": "application/patch-ops-error+xml",
+  "xfdf": "application/xfdf",
+  "xht": "application/xhtml+xml",
+  "xhtml": "application/xhtml+xml",
+  "xhvml": "application/xv+xml",
+  "xlf": "application/xliff+xml",
+  "xm": "audio/xm",
+  "xml": "text/xml",
+  "xns": "application/xcap-ns+xml",
+  "xop": "application/xop+xml",
+  "xpl": "application/xproc+xml",
+  "xsd": "application/xml",
+  "xsf": "application/prs.xsf+xml",
+  "xsl": "application/xml",
+  "xslt": "application/xml",
+  "xspf": "application/xspf+xml",
+  "xvm": "application/xv+xml",
+  "xvml": "application/xv+xml",
+  "yaml": "text/yaml",
+  "yang": "application/yang",
+  "yin": "application/yin+xml",
+  "yml": "text/yaml",
+  "zip": "application/zip"
+};
+
+function lookup(extn) {
+	let tmp = ('' + extn).trim().toLowerCase();
+	let idx = tmp.lastIndexOf('.');
+	return mimes[!~idx ? tmp : tmp.substring(++idx)];
+}
+
+const noop = () => {};
+
+function isMatch(uri, arr) {
+	for (let i=0; i < arr.length; i++) {
+		if (arr[i].test(uri)) return true;
+	}
+}
+
+function toAssume(uri, extns) {
+	let i=0, x, len=uri.length - 1;
+	if (uri.charCodeAt(len) === 47) {
+		uri = uri.substring(0, len);
+	}
+
+	let arr=[], tmp=`${uri}/index`;
+	for (; i < extns.length; i++) {
+		x = extns[i] ? `.${extns[i]}` : '';
+		if (uri) arr.push(uri + x);
+		arr.push(tmp + x);
+	}
+
+	return arr;
+}
+
+function viaCache(cache, uri, extns) {
+	let i=0, data, arr=toAssume(uri, extns);
+	for (; i < arr.length; i++) {
+		if (data = cache[arr[i]]) return data;
+	}
+}
+
+function viaLocal(dir, isEtag, uri, extns) {
+	let i=0, arr=toAssume(uri, extns);
+	let abs, stats, name, headers;
+	for (; i < arr.length; i++) {
+		abs = normalize(join(dir, name=arr[i]));
+		if (abs.startsWith(dir) && fs.existsSync(abs)) {
+			stats = fs.statSync(abs);
+			if (stats.isDirectory()) continue;
+			headers = toHeaders(name, stats, isEtag);
+			headers['Cache-Control'] = isEtag ? 'no-cache' : 'no-store';
+			return { abs, stats, headers };
+		}
+	}
+}
+
+function is404(req, res) {
+	return (res.statusCode=404,res.end());
+}
+
+function send(req, res, file, stats, headers) {
+	let code=200, tmp, opts={};
+	headers = { ...headers };
+
+	for (let key in headers) {
+		tmp = res.getHeader(key);
+		if (tmp) headers[key] = tmp;
+	}
+
+	if (tmp = res.getHeader('content-type')) {
+		headers['Content-Type'] = tmp;
+	}
+
+	if (req.headers.range) {
+		code = 206;
+		let [x, y] = req.headers.range.replace('bytes=', '').split('-');
+		let end = opts.end = parseInt(y, 10) || stats.size - 1;
+		let start = opts.start = parseInt(x, 10) || 0;
+
+		if (end >= stats.size) {
+			end = stats.size - 1;
+		}
+
+		if (start >= stats.size) {
+			res.setHeader('Content-Range', `bytes */${stats.size}`);
+			res.statusCode = 416;
+			return res.end();
+		}
+
+		headers['Content-Range'] = `bytes ${start}-${end}/${stats.size}`;
+		headers['Content-Length'] = (end - start + 1);
+		headers['Accept-Ranges'] = 'bytes';
+	}
+
+	res.writeHead(code, headers);
+	fs.createReadStream(file, opts).pipe(res);
+}
+
+const ENCODING = {
+	'.br': 'br',
+	'.gz': 'gzip',
+};
+
+function toHeaders(name, stats, isEtag) {
+	let enc = ENCODING[name.slice(-3)];
+
+	let ctype = lookup(name.slice(0, enc && -3)) || '';
+	if (ctype === 'text/html') ctype += ';charset=utf-8';
+
+	let headers = {
+		'Content-Length': stats.size,
+		'Content-Type': ctype,
+		'Last-Modified': stats.mtime.toUTCString(),
+	};
+
+	if (enc) headers['Content-Encoding'] = enc;
+	if (isEtag) headers['ETag'] = `W/"${stats.size}-${stats.mtime.getTime()}"`;
+
+	return headers;
+}
+
+function sirv (dir, opts={}) {
+	dir = resolve(dir || '.');
+
+	let isNotFound = opts.onNoMatch || is404;
+	let setHeaders = opts.setHeaders || noop;
+
+	let extensions = opts.extensions || ['html', 'htm'];
+	let gzips = opts.gzip && extensions.map(x => `${x}.gz`).concat('gz');
+	let brots = opts.brotli && extensions.map(x => `${x}.br`).concat('br');
+
+	const FILES = {};
+
+	let fallback = '/';
+	let isEtag = !!opts.etag;
+	let isSPA = !!opts.single;
+	if (typeof opts.single === 'string') {
+		let idx = opts.single.lastIndexOf('.');
+		fallback += !!~idx ? opts.single.substring(0, idx) : opts.single;
+	}
+
+	let ignores = [];
+	if (opts.ignores !== false) {
+		ignores.push(/[/]([A-Za-z\s\d~$._-]+\.\w+){1,}$/); // any extn
+		if (opts.dotfiles) ignores.push(/\/\.\w/);
+		else ignores.push(/\/\.well-known/);
+		[].concat(opts.ignores || []).forEach(x => {
+			ignores.push(new RegExp(x, 'i'));
+		});
+	}
+
+	let cc = opts.maxAge != null && `public,max-age=${opts.maxAge}`;
+	if (cc && opts.immutable) cc += ',immutable';
+	else if (cc && opts.maxAge === 0) cc += ',must-revalidate';
+
+	if (!opts.dev) {
+		totalist(dir, (name, abs, stats) => {
+			if (/\.well-known[\\+\/]/.test(name)) ; // keep
+			else if (!opts.dotfiles && /(^\.|[\\+|\/+]\.)/.test(name)) return;
+
+			let headers = toHeaders(name, stats, isEtag);
+			if (cc) headers['Cache-Control'] = cc;
+
+			FILES['/' + name.normalize().replace(/\\+/g, '/')] = { abs, stats, headers };
+		});
+	}
+
+	let lookup = opts.dev ? viaLocal.bind(0, dir, isEtag) : viaCache.bind(0, FILES);
+
+	return function (req, res, next) {
+		let extns = [''];
+		let pathname = parse$1(req).pathname;
+		let val = req.headers['accept-encoding'] || '';
+		if (gzips && val.includes('gzip')) extns.unshift(...gzips);
+		if (brots && /(br|brotli)/i.test(val)) extns.unshift(...brots);
+		extns.push(...extensions); // [...br, ...gz, orig, ...exts]
+
+		if (pathname.indexOf('%') !== -1) {
+			try { pathname = decodeURI(pathname); }
+			catch (err) { /* malform uri */ }
+		}
+
+		let data = lookup(pathname, extns) || isSPA && !isMatch(pathname, ignores) && lookup(fallback, extns);
+		if (!data) return next ? next() : isNotFound(req, res);
+
+		if (isEtag && req.headers['if-none-match'] === data.headers['ETag']) {
+			res.writeHead(304);
+			return res.end();
+		}
+
+		if (gzips || brots) {
+			res.setHeader('Vary', 'Accept-Encoding');
+		}
+
+		setHeaders(res, pathname, data.stats);
+		send(req, res, data.abs, data.stats, data.headers);
+	};
+}
+
+var setCookie = {exports: {}};
+
+var defaultParseOptions = {
+  decodeValues: true,
+  map: false,
+  silent: false,
+};
+
+function isNonEmptyString(str) {
+  return typeof str === "string" && !!str.trim();
+}
+
+function parseString(setCookieValue, options) {
+  var parts = setCookieValue.split(";").filter(isNonEmptyString);
+
+  var nameValuePairStr = parts.shift();
+  var parsed = parseNameValuePair(nameValuePairStr);
+  var name = parsed.name;
+  var value = parsed.value;
+
+  options = options
+    ? Object.assign({}, defaultParseOptions, options)
+    : defaultParseOptions;
+
+  try {
+    value = options.decodeValues ? decodeURIComponent(value) : value; // decode cookie value
+  } catch (e) {
+    console.error(
+      "set-cookie-parser encountered an error while decoding a cookie with value '" +
+        value +
+        "'. Set options.decodeValues to false to disable this feature.",
+      e
+    );
+  }
+
+  var cookie = {
+    name: name,
+    value: value,
+  };
+
+  parts.forEach(function (part) {
+    var sides = part.split("=");
+    var key = sides.shift().trimLeft().toLowerCase();
+    var value = sides.join("=");
+    if (key === "expires") {
+      cookie.expires = new Date(value);
+    } else if (key === "max-age") {
+      cookie.maxAge = parseInt(value, 10);
+    } else if (key === "secure") {
+      cookie.secure = true;
+    } else if (key === "httponly") {
+      cookie.httpOnly = true;
+    } else if (key === "samesite") {
+      cookie.sameSite = value;
+    } else {
+      cookie[key] = value;
+    }
+  });
+
+  return cookie;
+}
+
+function parseNameValuePair(nameValuePairStr) {
+  // Parses name-value-pair according to rfc6265bis draft
+
+  var name = "";
+  var value = "";
+  var nameValueArr = nameValuePairStr.split("=");
+  if (nameValueArr.length > 1) {
+    name = nameValueArr.shift();
+    value = nameValueArr.join("="); // everything after the first =, joined by a "=" if there was more than one part
+  } else {
+    value = nameValuePairStr;
+  }
+
+  return { name: name, value: value };
+}
+
+function parse(input, options) {
+  options = options
+    ? Object.assign({}, defaultParseOptions, options)
+    : defaultParseOptions;
+
+  if (!input) {
+    if (!options.map) {
+      return [];
+    } else {
+      return {};
+    }
+  }
+
+  if (input.headers) {
+    if (typeof input.headers.getSetCookie === "function") {
+      // for fetch responses - they combine headers of the same type in the headers array,
+      // but getSetCookie returns an uncombined array
+      input = input.headers.getSetCookie();
+    } else if (input.headers["set-cookie"]) {
+      // fast-path for node.js (which automatically normalizes header names to lower-case
+      input = input.headers["set-cookie"];
+    } else {
+      // slow-path for other environments - see #25
+      var sch =
+        input.headers[
+          Object.keys(input.headers).find(function (key) {
+            return key.toLowerCase() === "set-cookie";
+          })
+        ];
+      // warn if called on a request-like object with a cookie header rather than a set-cookie header - see #34, 36
+      if (!sch && input.headers.cookie && !options.silent) {
+        console.warn(
+          "Warning: set-cookie-parser appears to have been called on a request object. It is designed to parse Set-Cookie headers from responses, not Cookie headers from requests. Set the option {silent: true} to suppress this warning."
+        );
+      }
+      input = sch;
+    }
+  }
+  if (!Array.isArray(input)) {
+    input = [input];
+  }
+
+  options = options
+    ? Object.assign({}, defaultParseOptions, options)
+    : defaultParseOptions;
+
+  if (!options.map) {
+    return input.filter(isNonEmptyString).map(function (str) {
+      return parseString(str, options);
+    });
+  } else {
+    var cookies = {};
+    return input.filter(isNonEmptyString).reduce(function (cookies, str) {
+      var cookie = parseString(str, options);
+      cookies[cookie.name] = cookie;
+      return cookies;
+    }, cookies);
+  }
+}
+
+/*
+  Set-Cookie header field-values are sometimes comma joined in one string. This splits them without choking on commas
+  that are within a single set-cookie field-value, such as in the Expires portion.
+
+  This is uncommon, but explicitly allowed - see https://tools.ietf.org/html/rfc2616#section-4.2
+  Node.js does this for every header *except* set-cookie - see https://github.com/nodejs/node/blob/d5e363b77ebaf1caf67cd7528224b651c86815c1/lib/_http_incoming.js#L128
+  React Native's fetch does this for *every* header, including set-cookie.
+
+  Based on: https://github.com/google/j2objc/commit/16820fdbc8f76ca0c33472810ce0cb03d20efe25
+  Credits to: https://github.com/tomball for original and https://github.com/chrusart for JavaScript implementation
+*/
+function splitCookiesString(cookiesString) {
+  if (Array.isArray(cookiesString)) {
+    return cookiesString;
+  }
+  if (typeof cookiesString !== "string") {
+    return [];
+  }
+
+  var cookiesStrings = [];
+  var pos = 0;
+  var start;
+  var ch;
+  var lastComma;
+  var nextStart;
+  var cookiesSeparatorFound;
+
+  function skipWhitespace() {
+    while (pos < cookiesString.length && /\s/.test(cookiesString.charAt(pos))) {
+      pos += 1;
+    }
+    return pos < cookiesString.length;
+  }
+
+  function notSpecialChar() {
+    ch = cookiesString.charAt(pos);
+
+    return ch !== "=" && ch !== ";" && ch !== ",";
+  }
+
+  while (pos < cookiesString.length) {
+    start = pos;
+    cookiesSeparatorFound = false;
+
+    while (skipWhitespace()) {
+      ch = cookiesString.charAt(pos);
+      if (ch === ",") {
+        // ',' is a cookie separator if we have later first '=', not ';' or ','
+        lastComma = pos;
+        pos += 1;
+
+        skipWhitespace();
+        nextStart = pos;
+
+        while (pos < cookiesString.length && notSpecialChar()) {
+          pos += 1;
+        }
+
+        // currently special character
+        if (pos < cookiesString.length && cookiesString.charAt(pos) === "=") {
+          // we found cookies separator
+          cookiesSeparatorFound = true;
+          // pos is inside the next cookie, so back up and return it.
+          pos = nextStart;
+          cookiesStrings.push(cookiesString.substring(start, lastComma));
+          start = pos;
+        } else {
+          // in param ',' or param separator ';',
+          // we continue from that comma
+          pos = lastComma + 1;
+        }
+      } else {
+        pos += 1;
+      }
+    }
+
+    if (!cookiesSeparatorFound || pos >= cookiesString.length) {
+      cookiesStrings.push(cookiesString.substring(start, cookiesString.length));
+    }
+  }
+
+  return cookiesStrings;
+}
+
+setCookie.exports = parse;
+setCookie.exports.parse = parse;
+setCookie.exports.parseString = parseString;
+var splitCookiesString_1 = setCookie.exports.splitCookiesString = splitCookiesString;
+
+/**
+ * An error that was thrown from within the SvelteKit runtime that is not fatal and doesn't result in a 500, such as a 404.
+ * `SvelteKitError` goes through `handleError`.
+ * @extends Error
+ */
+class SvelteKitError extends Error {
+	/**
+	 * @param {number} status
+	 * @param {string} text
+	 * @param {string} message
+	 */
+	constructor(status, text, message) {
+		super(message);
+		this.status = status;
+		this.text = text;
+	}
+}
+
+/**
+ * @param {import('http').IncomingMessage} req
+ * @param {number} [body_size_limit]
+ */
+function get_raw_body(req, body_size_limit) {
+	const h = req.headers;
+
+	if (!h['content-type']) {
+		return null;
+	}
+
+	const content_length = Number(h['content-length']);
+
+	// check if no request body
+	if (
+		(req.httpVersionMajor === 1 && isNaN(content_length) && h['transfer-encoding'] == null) ||
+		content_length === 0
+	) {
+		return null;
+	}
+
+	if (req.destroyed) {
+		const readable = new ReadableStream();
+		readable.cancel();
+		return readable;
+	}
+
+	let size = 0;
+	let cancelled = false;
+
+	return new ReadableStream({
+		start(controller) {
+			if (body_size_limit !== undefined && content_length > body_size_limit) {
+				let message = `Content-length of ${content_length} exceeds limit of ${body_size_limit} bytes.`;
+
+				if (body_size_limit === 0) {
+					// https://github.com/sveltejs/kit/pull/11589
+					// TODO this exists to aid migration — remove in a future version
+					message += ' To disable body size limits, specify Infinity rather than 0.';
+				}
+
+				const error = new SvelteKitError(413, 'Payload Too Large', message);
+
+				controller.error(error);
+				return;
+			}
+
+			req.on('error', (error) => {
+				cancelled = true;
+				controller.error(error);
+			});
+
+			req.on('end', () => {
+				if (cancelled) return;
+				controller.close();
+			});
+
+			req.on('data', (chunk) => {
+				if (cancelled) return;
+
+				size += chunk.length;
+				if (size > content_length) {
+					cancelled = true;
+
+					const constraint = content_length ? 'content-length' : 'BODY_SIZE_LIMIT';
+					const message = `request body size exceeded ${constraint} of ${content_length}`;
+
+					const error = new SvelteKitError(413, 'Payload Too Large', message);
+					controller.error(error);
+
+					return;
+				}
+
+				controller.enqueue(chunk);
+
+				if (controller.desiredSize === null || controller.desiredSize <= 0) {
+					req.pause();
+				}
+			});
+		},
+
+		pull() {
+			req.resume();
+		},
+
+		cancel(reason) {
+			cancelled = true;
+			req.destroy(reason);
+		}
+	});
+}
+
+/**
+ * @param {{
+ *   request: import('http').IncomingMessage;
+ *   base: string;
+ *   bodySizeLimit?: number;
+ * }} options
+ * @returns {Promise<Request>}
+ */
+// TODO 3.0 make the signature synchronous?
+// eslint-disable-next-line @typescript-eslint/require-await
+async function getRequest({ request, base, bodySizeLimit }) {
+	return new Request(base + request.url, {
+		// @ts-expect-error
+		duplex: 'half',
+		method: request.method,
+		headers: /** @type {Record<string, string>} */ (request.headers),
+		body:
+			request.method === 'GET' || request.method === 'HEAD'
+				? undefined
+				: get_raw_body(request, bodySizeLimit)
+	});
+}
+
+/**
+ * @param {import('http').ServerResponse} res
+ * @param {Response} response
+ * @returns {Promise<void>}
+ */
+// TODO 3.0 make the signature synchronous?
+// eslint-disable-next-line @typescript-eslint/require-await
+async function setResponse(res, response) {
+	for (const [key, value] of response.headers) {
+		try {
+			res.setHeader(
+				key,
+				key === 'set-cookie'
+					? splitCookiesString_1(
+							// This is absurd but necessary, TODO: investigate why
+							/** @type {string}*/ (response.headers.get(key))
+						)
+					: value
+			);
+		} catch (error) {
+			res.getHeaderNames().forEach((name) => res.removeHeader(name));
+			res.writeHead(500).end(String(error));
+			return;
+		}
+	}
+
+	res.writeHead(response.status);
+
+	if (!response.body) {
+		res.end();
+		return;
+	}
+
+	if (response.body.locked) {
+		res.end(
+			'Fatal error: Response body is locked. ' +
+				"This can happen when the response was already read (for example through 'response.json()' or 'response.text()')."
+		);
+		return;
+	}
+
+	const reader = response.body.getReader();
+
+	if (res.destroyed) {
+		reader.cancel();
+		return;
+	}
+
+	const cancel = (/** @type {Error|undefined} */ error) => {
+		res.off('close', cancel);
+		res.off('error', cancel);
+
+		// If the reader has already been interrupted with an error earlier,
+		// then it will appear here, it is useless, but it needs to be catch.
+		reader.cancel(error).catch(() => {});
+		if (error) res.destroy(error);
+	};
+
+	res.on('close', cancel);
+	res.on('error', cancel);
+
+	next();
+	async function next() {
+		try {
+			for (;;) {
+				const { done, value } = await reader.read();
+
+				if (done) break;
+
+				if (!res.write(value)) {
+					res.once('drain', next);
+					return;
+				}
+			}
+			res.end();
+		} catch (error) {
+			cancel(error instanceof Error ? error : new Error(String(error)));
+		}
+	}
+}
+
+/**
+ * Converts a file on disk to a readable stream
+ * @param {string} file
+ * @returns {ReadableStream}
+ * @since 2.4.0
+ */
+function createReadableStream(file) {
+	return /** @type {ReadableStream} */ (Readable.toWeb(createReadStream(file)));
+}
+
+/* global ENV_PREFIX */
+
+const server = new Server(manifest);
+
+const origin = env('ORIGIN', undefined);
+const xff_depth = parseInt(env('XFF_DEPTH', '1'));
+const address_header = env('ADDRESS_HEADER', '').toLowerCase();
+const protocol_header = env('PROTOCOL_HEADER', '').toLowerCase();
+const host_header = env('HOST_HEADER', 'host').toLowerCase();
+const port_header = env('PORT_HEADER', '').toLowerCase();
+
+/**
+ * @param {string} bytes
+ */
+function parse_body_size_limit(bytes) {
+	const multiplier =
+		{
+			K: 1024,
+			M: 1024 * 1024,
+			G: 1024 * 1024 * 1024
+		}[bytes[bytes.length - 1]?.toUpperCase()] ?? 1;
+	return Number(multiplier != 1 ? bytes.substring(0, bytes.length - 1) : bytes) * multiplier;
+}
+
+const body_size_limit = parse_body_size_limit(env('BODY_SIZE_LIMIT', '512K'));
+
+if (isNaN(body_size_limit)) {
+	throw new Error(
+		`Invalid BODY_SIZE_LIMIT: '${env('BODY_SIZE_LIMIT')}'. Please provide a numeric value.`
+	);
+}
+
+const dir = path.dirname(fileURLToPath(import.meta.url));
+
+const asset_dir = `${dir}/client${base}`;
+
+await server.init({
+	env: process.env,
+	read: (file) => createReadableStream(`${asset_dir}/${file}`)
+});
+
+/**
+ * @param {string} path
+ * @param {boolean} client
+ */
+function serve(path, client = false) {
+	return (
+		fs$1.existsSync(path) &&
+		sirv(path, {
+			etag: true,
+			gzip: true,
+			brotli: true,
+			setHeaders:
+				client &&
+				((res, pathname) => {
+					// only apply to build directory, not e.g. version.json
+					if (pathname.startsWith(`/${manifest.appPath}/immutable/`) && res.statusCode === 200) {
+						res.setHeader('cache-control', 'public,max-age=31536000,immutable');
+					}
+				})
+		})
+	);
+}
+
+// required because the static file server ignores trailing slashes
+/** @returns {import('polka').Middleware} */
+function serve_prerendered() {
+	const handler = serve(path.join(dir, 'prerendered'));
+
+	return (req, res, next) => {
+		let { pathname, search, query } = parse$1(req);
+
+		try {
+			pathname = decodeURIComponent(pathname);
+		} catch {
+			// ignore invalid URI
+		}
+
+		if (prerendered.has(pathname)) {
+			return handler(req, res, next);
+		}
+
+		// remove or add trailing slash as appropriate
+		let location = pathname.at(-1) === '/' ? pathname.slice(0, -1) : pathname + '/';
+		if (prerendered.has(location)) {
+			if (query) location += search;
+			res.writeHead(308, { location }).end();
+		} else {
+			next();
+		}
+	};
+}
+
+/** @type {import('polka').Middleware} */
+const ssr = async (req, res) => {
+	/** @type {Request} */
+	let request;
+
+	try {
+		request = await getRequest({
+			base: origin || get_origin(req.headers),
+			request: req,
+			bodySizeLimit: body_size_limit
+		});
+	} catch {
+		res.statusCode = 400;
+		res.end('Bad Request');
+		return;
+	}
+
+	setResponse(
+		res,
+		await server.respond(request, {
+			platform: { req },
+			getClientAddress: () => {
+				if (address_header) {
+					if (!(address_header in req.headers)) {
+						throw new Error(
+							`Address header was specified with ${
+								ENV_PREFIX + 'ADDRESS_HEADER'
+							}=${address_header} but is absent from request`
+						);
+					}
+
+					const value = /** @type {string} */ (req.headers[address_header]) || '';
+
+					if (address_header === 'x-forwarded-for') {
+						const addresses = value.split(',');
+
+						if (xff_depth < 1) {
+							throw new Error(`${ENV_PREFIX + 'XFF_DEPTH'} must be a positive integer`);
+						}
+
+						if (xff_depth > addresses.length) {
+							throw new Error(
+								`${ENV_PREFIX + 'XFF_DEPTH'} is ${xff_depth}, but only found ${
+									addresses.length
+								} addresses`
+							);
+						}
+						return addresses[addresses.length - xff_depth].trim();
+					}
+
+					return value;
+				}
+
+				return (
+					req.connection?.remoteAddress ||
+					// @ts-expect-error
+					req.connection?.socket?.remoteAddress ||
+					req.socket?.remoteAddress ||
+					// @ts-expect-error
+					req.info?.remoteAddress
+				);
+			}
+		})
+	);
+};
+
+/** @param {import('polka').Middleware[]} handlers */
+function sequence(handlers) {
+	/** @type {import('polka').Middleware} */
+	return (req, res, next) => {
+		/**
+		 * @param {number} i
+		 * @returns {ReturnType<import('polka').Middleware>}
+		 */
+		function handle(i) {
+			if (i < handlers.length) {
+				return handlers[i](req, res, () => handle(i + 1));
+			} else {
+				return next();
+			}
+		}
+
+		return handle(0);
+	};
+}
+
+/**
+ * @param {import('http').IncomingHttpHeaders} headers
+ * @returns
+ */
+function get_origin(headers) {
+	const protocol = (protocol_header && headers[protocol_header]) || 'https';
+	const host = headers[host_header];
+	const port = port_header && headers[port_header];
+	if (port) {
+		return `${protocol}://${host}:${port}`;
+	} else {
+		return `${protocol}://${host}`;
+	}
+}
+
+const handler = sequence(
+	[
+		serve(path.join(dir, 'client'), true),
+		serve(path.join(dir, 'static')),
+		serve(path.join(dir, 'fallback'), true),
+		serve_prerendered(),
+		ssr
+	].filter(Boolean)
+);
+
+export { handler };
diff --git a/node_modules/@sveltejs/adapter-node/.3fedfcffd71d7bee-00000008.README.md b/node_modules/@sveltejs/adapter-node/.3fedfcffd71d7bee-00000008.README.md
new file mode 100644
index 0000000..978aa47
--- /dev/null
+++ b/node_modules/@sveltejs/adapter-node/.3fedfcffd71d7bee-00000008.README.md
@@ -0,0 +1,15 @@
+# @sveltejs/adapter-node
+
+[Adapter](https://kit.svelte.dev/docs/adapters) for SvelteKit apps that generates a standalone Node server.
+
+## Docs
+
+[Docs](https://kit.svelte.dev/docs/adapter-node)
+
+## Changelog
+
+[The Changelog for this package is available on GitHub](https://github.com/sveltejs/kit/blob/main/packages/adapter-node/CHANGELOG.md).
+
+## License
+
+[MIT](LICENSE)
diff --git a/node_modules/@sveltejs/adapter-node/.3ffdfcec4bdf9bec-00000008.README.md b/node_modules/@sveltejs/adapter-node/.3ffdfcec4bdf9bec-00000008.README.md
new file mode 100644
index 0000000..978aa47
--- /dev/null
+++ b/node_modules/@sveltejs/adapter-node/.3ffdfcec4bdf9bec-00000008.README.md
@@ -0,0 +1,15 @@
+# @sveltejs/adapter-node
+
+[Adapter](https://kit.svelte.dev/docs/adapters) for SvelteKit apps that generates a standalone Node server.
+
+## Docs
+
+[Docs](https://kit.svelte.dev/docs/adapter-node)
+
+## Changelog
+
+[The Changelog for this package is available on GitHub](https://github.com/sveltejs/kit/blob/main/packages/adapter-node/CHANGELOG.md).
+
+## License
+
+[MIT](LICENSE)
diff --git a/node_modules/@sveltejs/adapter-node/.57fddebbf9ff657a-00000003.shims.js b/node_modules/@sveltejs/adapter-node/.57fddebbf9ff657a-00000003.shims.js
new file mode 100644
index 0000000..9cddad8
--- /dev/null
+++ b/node_modules/@sveltejs/adapter-node/.57fddebbf9ff657a-00000003.shims.js
@@ -0,0 +1,32 @@
+import buffer from 'node:buffer';
+import { webcrypto } from 'node:crypto';
+
+// `buffer.File` was added in Node 18.13.0 while the `File` global was added in Node 20.0.0
+const File = /** @type {import('node:buffer') & { File?: File}} */ (buffer).File;
+
+/** @type {Record<string, any>} */
+const globals = {
+	crypto: webcrypto,
+	File
+};
+
+// exported for dev/preview and node environments
+/**
+ * Make various web APIs available as globals:
+ * - `crypto`
+ * - `File`
+ */
+function installPolyfills() {
+	for (const name in globals) {
+		if (name in globalThis) continue;
+
+		Object.defineProperty(globalThis, name, {
+			enumerable: true,
+			configurable: true,
+			writable: true,
+			value: globals[name]
+		});
+	}
+}
+
+installPolyfills();
diff --git a/node_modules/@sveltejs/adapter-node/.5feddfedddf34f7d-00000000.env.js b/node_modules/@sveltejs/adapter-node/.5feddfedddf34f7d-00000000.env.js
new file mode 100644
index 0000000..baed52c
--- /dev/null
+++ b/node_modules/@sveltejs/adapter-node/.5feddfedddf34f7d-00000000.env.js
@@ -0,0 +1,43 @@
+/* global ENV_PREFIX */
+
+const expected = new Set([
+	'SOCKET_PATH',
+	'HOST',
+	'PORT',
+	'ORIGIN',
+	'XFF_DEPTH',
+	'ADDRESS_HEADER',
+	'PROTOCOL_HEADER',
+	'HOST_HEADER',
+	'PORT_HEADER',
+	'BODY_SIZE_LIMIT',
+	'SHUTDOWN_TIMEOUT',
+	'IDLE_TIMEOUT'
+]);
+
+const expected_unprefixed = new Set(['LISTEN_PID', 'LISTEN_FDS']);
+
+if (ENV_PREFIX) {
+	for (const name in process.env) {
+		if (name.startsWith(ENV_PREFIX)) {
+			const unprefixed = name.slice(ENV_PREFIX.length);
+			if (!expected.has(unprefixed)) {
+				throw new Error(
+					`You should change envPrefix (${ENV_PREFIX}) to avoid conflicts with existing environment variables — unexpectedly saw ${name}`
+				);
+			}
+		}
+	}
+}
+
+/**
+ * @param {string} name
+ * @param {any} fallback
+ */
+function env(name, fallback) {
+	const prefix = expected_unprefixed.has(name) ? '' : ENV_PREFIX;
+	const prefixed = prefix + name;
+	return prefixed in process.env ? process.env[prefixed] : fallback;
+}
+
+export { env };
diff --git a/node_modules/@sveltejs/adapter-node/.5ffddcbb77bbbfef-00000004.index.d.ts b/node_modules/@sveltejs/adapter-node/.5ffddcbb77bbbfef-00000004.index.d.ts
new file mode 100644
index 0000000..27c6f53
--- /dev/null
+++ b/node_modules/@sveltejs/adapter-node/.5ffddcbb77bbbfef-00000004.index.d.ts
@@ -0,0 +1,15 @@
+import { Adapter } from '@sveltejs/kit';
+import './ambient.js';
+
+declare global {
+	const ENV_PREFIX: string;
+}
+
+interface AdapterOptions {
+	out?: string;
+	precompress?: boolean;
+	fallback?: string;
+	envPrefix?: string;
+}
+
+export default function plugin(options?: AdapterOptions): Adapter;
diff --git a/node_modules/@sveltejs/adapter-node/.77efffffeedffbf8-00000000.env.js b/node_modules/@sveltejs/adapter-node/.77efffffeedffbf8-00000000.env.js
new file mode 100644
index 0000000..baed52c
--- /dev/null
+++ b/node_modules/@sveltejs/adapter-node/.77efffffeedffbf8-00000000.env.js
@@ -0,0 +1,43 @@
+/* global ENV_PREFIX */
+
+const expected = new Set([
+	'SOCKET_PATH',
+	'HOST',
+	'PORT',
+	'ORIGIN',
+	'XFF_DEPTH',
+	'ADDRESS_HEADER',
+	'PROTOCOL_HEADER',
+	'HOST_HEADER',
+	'PORT_HEADER',
+	'BODY_SIZE_LIMIT',
+	'SHUTDOWN_TIMEOUT',
+	'IDLE_TIMEOUT'
+]);
+
+const expected_unprefixed = new Set(['LISTEN_PID', 'LISTEN_FDS']);
+
+if (ENV_PREFIX) {
+	for (const name in process.env) {
+		if (name.startsWith(ENV_PREFIX)) {
+			const unprefixed = name.slice(ENV_PREFIX.length);
+			if (!expected.has(unprefixed)) {
+				throw new Error(
+					`You should change envPrefix (${ENV_PREFIX}) to avoid conflicts with existing environment variables — unexpectedly saw ${name}`
+				);
+			}
+		}
+	}
+}
+
+/**
+ * @param {string} name
+ * @param {any} fallback
+ */
+function env(name, fallback) {
+	const prefix = expected_unprefixed.has(name) ? '' : ENV_PREFIX;
+	const prefixed = prefix + name;
+	return prefixed in process.env ? process.env[prefixed] : fallback;
+}
+
+export { env };
diff --git a/node_modules/@sveltejs/adapter-node/.77fdfeff7ffbff58-00000005.index.js b/node_modules/@sveltejs/adapter-node/.77fdfeff7ffbff58-00000005.index.js
new file mode 100644
index 0000000..cd5e267
--- /dev/null
+++ b/node_modules/@sveltejs/adapter-node/.77fdfeff7ffbff58-00000005.index.js
@@ -0,0 +1,102 @@
+import { readFileSync, writeFileSync } from 'node:fs';
+import { fileURLToPath } from 'node:url';
+import { rollup } from 'rollup';
+import { nodeResolve } from '@rollup/plugin-node-resolve';
+import commonjs from '@rollup/plugin-commonjs';
+import json from '@rollup/plugin-json';
+
+const files = fileURLToPath(new URL('./files', import.meta.url).href);
+
+/** @type {import('./index.js').default} */
+export default function (opts = {}) {
+	const { out = 'build', precompress = true, envPrefix = '' } = opts;
+
+	return {
+		name: '@sveltejs/adapter-node',
+
+		async adapt(builder) {
+			const tmp = builder.getBuildDirectory('adapter-node');
+
+			builder.rimraf(out);
+			builder.rimraf(tmp);
+			builder.mkdirp(tmp);
+
+			builder.log.minor('Copying assets');
+			builder.writeClient(`${out}/client${builder.config.kit.paths.base}`);
+			builder.writePrerendered(`${out}/prerendered${builder.config.kit.paths.base}`);
+			
+			if (opts.fallback) {
+				builder.generateFallback(`${out}/fallback`, opts.fallback)
+			}
+
+			if (precompress) {
+				builder.log.minor('Compressing assets');
+				await Promise.all([
+					builder.compress(`${out}/client`),
+					builder.compress(`${out}/prerendered`)
+				]);
+			}
+
+			builder.log.minor('Building server');
+
+			builder.writeServer(tmp);
+
+			writeFileSync(
+				`${tmp}/manifest.js`,
+				[
+					`export const manifest = ${builder.generateManifest({ relativePath: './' })};`,
+					`export const prerendered = new Set(${JSON.stringify(builder.prerendered.paths)});`,
+					`export const base = ${JSON.stringify(builder.config.kit.paths.base)};`
+				].join('\n\n')
+			);
+
+			const pkg = JSON.parse(readFileSync('package.json', 'utf8'));
+
+			// we bundle the Vite output so that deployments only need
+			// their production dependencies. Anything in devDependencies
+			// will get included in the bundled code
+			const bundle = await rollup({
+				input: {
+					index: `${tmp}/index.js`,
+					manifest: `${tmp}/manifest.js`
+				},
+				external: [
+					// dependencies could have deep exports, so we need a regex
+					...Object.keys(pkg.dependencies || {}).map((d) => new RegExp(`^${d}(\\/.*)?$`))
+				],
+				plugins: [
+					nodeResolve({
+						preferBuiltins: true,
+						exportConditions: ['node']
+					}),
+					// @ts-ignore https://github.com/rollup/plugins/issues/1329
+					commonjs({ strictRequires: true }),
+					// @ts-ignore https://github.com/rollup/plugins/issues/1329
+					json()
+				]
+			});
+
+			await bundle.write({
+				dir: `${out}/server`,
+				format: 'esm',
+				sourcemap: true,
+				chunkFileNames: 'chunks/[name]-[hash].js'
+			});
+
+			builder.copy(files, out, {
+				replace: {
+					ENV: './env.js',
+					HANDLER: './handler.js',
+					MANIFEST: './server/manifest.js',
+					SERVER: './server/index.js',
+					SHIMS: './shims.js',
+					ENV_PREFIX: JSON.stringify(envPrefix)
+				}
+			});
+		},
+
+		supports: {
+			read: () => true
+		}
+	};
+}
diff --git a/node_modules/@sveltejs/adapter-node/.7feddfbbfb3e7c58-00000002.index.js b/node_modules/@sveltejs/adapter-node/.7feddfbbfb3e7c58-00000002.index.js
new file mode 100644
index 0000000..7b0ab9c
--- /dev/null
+++ b/node_modules/@sveltejs/adapter-node/.7feddfbbfb3e7c58-00000002.index.js
@@ -0,0 +1,332 @@
+import { handler } from 'HANDLER';
+import { env } from 'ENV';
+import http from 'http';
+import * as qs from 'querystring';
+
+/**
+ * @param {string|RegExp} input The route pattern
+ * @param {boolean} [loose] Allow open-ended matching. Ignored with `RegExp` input.
+ */
+function parse$1(input, loose) {
+	if (input instanceof RegExp) return { keys:false, pattern:input };
+	var c, o, tmp, ext, keys=[], pattern='', arr = input.split('/');
+	arr[0] || arr.shift();
+
+	while (tmp = arr.shift()) {
+		c = tmp[0];
+		if (c === '*') {
+			keys.push(c);
+			pattern += tmp[1] === '?' ? '(?:/(.*))?' : '/(.*)';
+		} else if (c === ':') {
+			o = tmp.indexOf('?', 1);
+			ext = tmp.indexOf('.', 1);
+			keys.push( tmp.substring(1, !!~o ? o : !!~ext ? ext : tmp.length) );
+			pattern += !!~o && !~ext ? '(?:/([^/]+?))?' : '/([^/]+?)';
+			if (!!~ext) pattern += (!!~o ? '?' : '') + '\\' + tmp.substring(ext);
+		} else {
+			pattern += '/' + tmp;
+		}
+	}
+
+	return {
+		keys: keys,
+		pattern: new RegExp('^' + pattern + (loose ? '(?=$|\/)' : '\/?$'), 'i')
+	};
+}
+
+const MAP = {
+	"": 0,
+	GET: 1,
+	HEAD: 2,
+	PATCH: 3,
+	OPTIONS: 4,
+	CONNECT: 5,
+	DELETE: 6,
+	TRACE: 7,
+	POST: 8,
+	PUT: 9,
+};
+
+class Trouter {
+	constructor() {
+		this.routes = [];
+
+		this.all = this.add.bind(this, '');
+		this.get = this.add.bind(this, 'GET');
+		this.head = this.add.bind(this, 'HEAD');
+		this.patch = this.add.bind(this, 'PATCH');
+		this.options = this.add.bind(this, 'OPTIONS');
+		this.connect = this.add.bind(this, 'CONNECT');
+		this.delete = this.add.bind(this, 'DELETE');
+		this.trace = this.add.bind(this, 'TRACE');
+		this.post = this.add.bind(this, 'POST');
+		this.put = this.add.bind(this, 'PUT');
+	}
+
+	use(route, ...fns) {
+		let handlers = [].concat.apply([], fns);
+		let { keys, pattern } = parse$1(route, true);
+		this.routes.push({ keys, pattern, method: '', handlers, midx: MAP[''] });
+		return this;
+	}
+
+	add(method, route, ...fns) {
+		let { keys, pattern } = parse$1(route);
+		let handlers = [].concat.apply([], fns);
+		this.routes.push({ keys, pattern, method, handlers, midx: MAP[method] });
+		return this;
+	}
+
+	find(method, url) {
+		let midx = MAP[method];
+		let isHEAD = (midx === 2);
+		let i=0, j=0, k, tmp, arr=this.routes;
+		let matches=[], params={}, handlers=[];
+		for (; i < arr.length; i++) {
+			tmp = arr[i];
+			if (tmp.midx === midx  || tmp.midx === 0 || (isHEAD && tmp.midx===1) ) {
+				if (tmp.keys === false) {
+					matches = tmp.pattern.exec(url);
+					if (matches === null) continue;
+					if (matches.groups !== void 0) for (k in matches.groups) params[k]=matches.groups[k];
+					tmp.handlers.length > 1 ? (handlers=handlers.concat(tmp.handlers)) : handlers.push(tmp.handlers[0]);
+				} else if (tmp.keys.length > 0) {
+					matches = tmp.pattern.exec(url);
+					if (matches === null) continue;
+					for (j=0; j < tmp.keys.length;) params[tmp.keys[j]]=matches[++j];
+					tmp.handlers.length > 1 ? (handlers=handlers.concat(tmp.handlers)) : handlers.push(tmp.handlers[0]);
+				} else if (tmp.pattern.test(url)) {
+					tmp.handlers.length > 1 ? (handlers=handlers.concat(tmp.handlers)) : handlers.push(tmp.handlers[0]);
+				}
+			} // else not a match
+		}
+
+		return { params, handlers };
+	}
+}
+
+/**
+ * @typedef ParsedURL
+ * @type {import('.').ParsedURL}
+ */
+
+/**
+ * @typedef Request
+ * @property {string} url
+ * @property {ParsedURL} _parsedUrl
+ */
+
+/**
+ * @param {Request} req
+ * @returns {ParsedURL|void}
+ */
+function parse(req) {
+	let raw = req.url;
+	if (raw == null) return;
+
+	let prev = req._parsedUrl;
+	if (prev && prev.raw === raw) return prev;
+
+	let pathname=raw, search='', query;
+
+	if (raw.length > 1) {
+		let idx = raw.indexOf('?', 1);
+
+		if (idx !== -1) {
+			search = raw.substring(idx);
+			pathname = raw.substring(0, idx);
+			if (search.length > 1) {
+				query = qs.parse(search.substring(1));
+			}
+		}
+	}
+
+	return req._parsedUrl = { pathname, search, query, raw };
+}
+
+function onError(err, req, res) {
+	let code = typeof err.status === 'number' && err.status;
+	code = res.statusCode = (code && code >= 100 ? code : 500);
+	if (typeof err === 'string' || Buffer.isBuffer(err)) res.end(err);
+	else res.end(err.message || http.STATUS_CODES[code]);
+}
+
+const mount = fn => fn instanceof Polka ? fn.attach : fn;
+
+class Polka extends Trouter {
+	constructor(opts={}) {
+		super();
+		this.parse = parse;
+		this.server = opts.server;
+		this.handler = this.handler.bind(this);
+		this.onError = opts.onError || onError; // catch-all handler
+		this.onNoMatch = opts.onNoMatch || this.onError.bind(null, { status: 404 });
+		this.attach = (req, res) => setImmediate(this.handler, req, res);
+	}
+
+	use(base, ...fns) {
+		if (base === '/') {
+			super.use(base, fns.map(mount));
+		} else if (typeof base === 'function' || base instanceof Polka) {
+			super.use('/', [base, ...fns].map(mount));
+		} else {
+			super.use(base,
+				(req, _, next) => {
+					if (typeof base === 'string') {
+						let len = base.length;
+						base.startsWith('/') || len++;
+						req.url = req.url.substring(len) || '/';
+						req.path = req.path.substring(len) || '/';
+					} else {
+						req.url = req.url.replace(base, '') || '/';
+						req.path = req.path.replace(base, '') || '/';
+					}
+					if (req.url.charAt(0) !== '/') {
+						req.url = '/' + req.url;
+					}
+					next();
+				},
+				fns.map(mount),
+				(req, _, next) => {
+					req.path = req._parsedUrl.pathname;
+					req.url = req.path + req._parsedUrl.search;
+					next();
+				}
+			);
+		}
+		return this; // chainable
+	}
+
+	listen() {
+		(this.server = this.server || http.createServer()).on('request', this.attach);
+		this.server.listen.apply(this.server, arguments);
+		return this;
+	}
+
+	handler(req, res, next) {
+		let info = this.parse(req), path = info.pathname;
+		let obj = this.find(req.method, req.path=path);
+
+		req.url = path + info.search;
+		req.originalUrl = req.originalUrl || req.url;
+		req.query = info.query || {};
+		req.search = info.search;
+		req.params = obj.params;
+
+		if (path.length > 1 && path.indexOf('%', 1) !== -1) {
+			for (let k in req.params) {
+				try { req.params[k] = decodeURIComponent(req.params[k]); }
+				catch (e) { /* malform uri segment */ }
+			}
+		}
+
+		let i=0, arr=obj.handlers.concat(this.onNoMatch), len=arr.length;
+		let loop = async () => res.finished || (i < len) && arr[i++](req, res, next);
+		(next = next || (err => err ? this.onError(err, req, res, next) : loop().catch(next)))(); // init
+	}
+}
+
+function polka (opts) {
+	return new Polka(opts);
+}
+
+const path = env('SOCKET_PATH', false);
+const host = env('HOST', '0.0.0.0');
+const port = env('PORT', !path && '3000');
+
+const shutdown_timeout = parseInt(env('SHUTDOWN_TIMEOUT', '30'));
+const idle_timeout = parseInt(env('IDLE_TIMEOUT', '0'));
+const listen_pid = parseInt(env('LISTEN_PID', '0'));
+const listen_fds = parseInt(env('LISTEN_FDS', '0'));
+// https://www.freedesktop.org/software/systemd/man/latest/sd_listen_fds.html
+const SD_LISTEN_FDS_START = 3;
+
+if (listen_pid !== 0 && listen_pid !== process.pid) {
+	throw new Error(`received LISTEN_PID ${listen_pid} but current process id is ${process.pid}`);
+}
+if (listen_fds > 1) {
+	throw new Error(
+		`only one socket is allowed for socket activation, but LISTEN_FDS was set to ${listen_fds}`
+	);
+}
+
+const socket_activation = listen_pid === process.pid && listen_fds === 1;
+
+let requests = 0;
+/** @type {NodeJS.Timeout | void} */
+let shutdown_timeout_id;
+/** @type {NodeJS.Timeout | void} */
+let idle_timeout_id;
+
+const server = polka().use(handler);
+
+if (socket_activation) {
+	server.listen({ fd: SD_LISTEN_FDS_START }, () => {
+		console.log(`Listening on file descriptor ${SD_LISTEN_FDS_START}`);
+	});
+} else {
+	server.listen({ path, host, port }, () => {
+		console.log(`Listening on ${path ? path : host + ':' + port}`);
+	});
+}
+
+/** @param {'SIGINT' | 'SIGTERM' | 'IDLE'} reason */
+function graceful_shutdown(reason) {
+	if (shutdown_timeout_id) return;
+
+	// If a connection was opened with a keep-alive header close() will wait for the connection to
+	// time out rather than close it even if it is not handling any requests, so call this first
+	// @ts-expect-error this was added in 18.2.0 but is not reflected in the types
+	server.server.closeIdleConnections();
+
+	server.server.close((error) => {
+		// occurs if the server is already closed
+		if (error) return;
+
+		if (shutdown_timeout_id) {
+			clearTimeout(shutdown_timeout_id);
+		}
+		if (idle_timeout_id) {
+			clearTimeout(idle_timeout_id);
+		}
+
+		// @ts-expect-error custom events cannot be typed
+		process.emit('sveltekit:shutdown', reason);
+	});
+
+	shutdown_timeout_id = setTimeout(
+		// @ts-expect-error this was added in 18.2.0 but is not reflected in the types
+		() => server.server.closeAllConnections(),
+		shutdown_timeout * 1000
+	);
+}
+
+server.server.on(
+	'request',
+	/** @param {import('node:http').IncomingMessage} req */
+	(req) => {
+		requests++;
+
+		if (socket_activation && idle_timeout_id) {
+			idle_timeout_id = clearTimeout(idle_timeout_id);
+		}
+
+		req.on('close', () => {
+			requests--;
+
+			if (shutdown_timeout_id) {
+				// close connections as soon as they become idle, so they don't accept new requests
+				// @ts-expect-error this was added in 18.2.0 but is not reflected in the types
+				server.server.closeIdleConnections();
+			}
+			if (requests === 0 && socket_activation && idle_timeout) {
+				idle_timeout_id = setTimeout(() => graceful_shutdown('IDLE'), idle_timeout * 1000);
+			}
+		});
+	}
+);
+
+process.on('SIGTERM', graceful_shutdown);
+process.on('SIGINT', graceful_shutdown);
+
+export { host, path, port, server };
diff --git a/node_modules/@sveltejs/adapter-node/.7feddffdeada7fdd-00000004.index.d.ts b/node_modules/@sveltejs/adapter-node/.7feddffdeada7fdd-00000004.index.d.ts
new file mode 100644
index 0000000..d32510e
--- /dev/null
+++ b/node_modules/@sveltejs/adapter-node/.7feddffdeada7fdd-00000004.index.d.ts
@@ -0,0 +1,14 @@
+import { Adapter } from '@sveltejs/kit';
+import './ambient.js';
+
+declare global {
+	const ENV_PREFIX: string;
+}
+
+interface AdapterOptions {
+	out?: string;
+	precompress?: boolean;
+	envPrefix?: string;
+}
+
+export default function plugin(options?: AdapterOptions): Adapter;
diff --git a/node_modules/@sveltejs/adapter-node/.7ffffdfe5f9cffa6-00000006.LICENSE b/node_modules/@sveltejs/adapter-node/.7ffffdfe5f9cffa6-00000006.LICENSE
new file mode 100644
index 0000000..22efd0c
--- /dev/null
+++ b/node_modules/@sveltejs/adapter-node/.7ffffdfe5f9cffa6-00000006.LICENSE
@@ -0,0 +1,7 @@
+Copyright (c) 2020 [these people](https://github.com/sveltejs/kit/graphs/contributors)
+
+Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
\ No newline at end of file
diff --git a/node_modules/@sveltejs/adapter-node/.9fedddffcbbf4ed9-00000007.package.json b/node_modules/@sveltejs/adapter-node/.9fedddffcbbf4ed9-00000007.package.json
new file mode 100644
index 0000000..e0cb434
--- /dev/null
+++ b/node_modules/@sveltejs/adapter-node/.9fedddffcbbf4ed9-00000007.package.json
@@ -0,0 +1,61 @@
+{
+  "name": "@sveltejs/adapter-node",
+  "version": "5.2.0",
+  "description": "Adapter for SvelteKit apps that generates a standalone Node server",
+  "keywords": [
+    "adapter",
+    "deploy",
+    "hosting",
+    "node.js",
+    "svelte",
+    "sveltekit"
+  ],
+  "repository": {
+    "type": "git",
+    "url": "https://github.com/sveltejs/kit",
+    "directory": "packages/adapter-node"
+  },
+  "license": "MIT",
+  "homepage": "https://kit.svelte.dev",
+  "type": "module",
+  "exports": {
+    ".": {
+      "types": "./index.d.ts",
+      "import": "./index.js"
+    },
+    "./package.json": "./package.json"
+  },
+  "types": "index.d.ts",
+  "files": [
+    "files",
+    "index.js",
+    "index.d.ts"
+  ],
+  "devDependencies": {
+    "@polka/url": "1.0.0-next.25",
+    "@sveltejs/vite-plugin-svelte": "^3.0.1",
+    "@types/node": "^18.19.3",
+    "polka": "1.0.0-next.25",
+    "sirv": "^2.0.4",
+    "typescript": "^5.3.3",
+    "vitest": "^1.6.0",
+    "@sveltejs/kit": "^2.5.17"
+  },
+  "dependencies": {
+    "@rollup/plugin-commonjs": "^26.0.1",
+    "@rollup/plugin-json": "^6.1.0",
+    "@rollup/plugin-node-resolve": "^15.2.3",
+    "rollup": "^4.9.5"
+  },
+  "peerDependencies": {
+    "@sveltejs/kit": "^2.4.0"
+  },
+  "scripts": {
+    "dev": "node -e \"fs.rmSync('files', { force: true, recursive: true })\" && rollup -cw",
+    "build": "node -e \"fs.rmSync('files', { force: true, recursive: true })\" && rollup -c",
+    "test": "echo \"tests temporarily disabled\" # vitest run",
+    "check": "tsc",
+    "lint": "prettier --check .",
+    "format": "pnpm lint --write"
+  }
+}
\ No newline at end of file
diff --git a/node_modules/@sveltejs/adapter-node/.b7ffddfeffdf76bb-00000005.index.js b/node_modules/@sveltejs/adapter-node/.b7ffddfeffdf76bb-00000005.index.js
new file mode 100644
index 0000000..cd5e267
--- /dev/null
+++ b/node_modules/@sveltejs/adapter-node/.b7ffddfeffdf76bb-00000005.index.js
@@ -0,0 +1,102 @@
+import { readFileSync, writeFileSync } from 'node:fs';
+import { fileURLToPath } from 'node:url';
+import { rollup } from 'rollup';
+import { nodeResolve } from '@rollup/plugin-node-resolve';
+import commonjs from '@rollup/plugin-commonjs';
+import json from '@rollup/plugin-json';
+
+const files = fileURLToPath(new URL('./files', import.meta.url).href);
+
+/** @type {import('./index.js').default} */
+export default function (opts = {}) {
+	const { out = 'build', precompress = true, envPrefix = '' } = opts;
+
+	return {
+		name: '@sveltejs/adapter-node',
+
+		async adapt(builder) {
+			const tmp = builder.getBuildDirectory('adapter-node');
+
+			builder.rimraf(out);
+			builder.rimraf(tmp);
+			builder.mkdirp(tmp);
+
+			builder.log.minor('Copying assets');
+			builder.writeClient(`${out}/client${builder.config.kit.paths.base}`);
+			builder.writePrerendered(`${out}/prerendered${builder.config.kit.paths.base}`);
+			
+			if (opts.fallback) {
+				builder.generateFallback(`${out}/fallback`, opts.fallback)
+			}
+
+			if (precompress) {
+				builder.log.minor('Compressing assets');
+				await Promise.all([
+					builder.compress(`${out}/client`),
+					builder.compress(`${out}/prerendered`)
+				]);
+			}
+
+			builder.log.minor('Building server');
+
+			builder.writeServer(tmp);
+
+			writeFileSync(
+				`${tmp}/manifest.js`,
+				[
+					`export const manifest = ${builder.generateManifest({ relativePath: './' })};`,
+					`export const prerendered = new Set(${JSON.stringify(builder.prerendered.paths)});`,
+					`export const base = ${JSON.stringify(builder.config.kit.paths.base)};`
+				].join('\n\n')
+			);
+
+			const pkg = JSON.parse(readFileSync('package.json', 'utf8'));
+
+			// we bundle the Vite output so that deployments only need
+			// their production dependencies. Anything in devDependencies
+			// will get included in the bundled code
+			const bundle = await rollup({
+				input: {
+					index: `${tmp}/index.js`,
+					manifest: `${tmp}/manifest.js`
+				},
+				external: [
+					// dependencies could have deep exports, so we need a regex
+					...Object.keys(pkg.dependencies || {}).map((d) => new RegExp(`^${d}(\\/.*)?$`))
+				],
+				plugins: [
+					nodeResolve({
+						preferBuiltins: true,
+						exportConditions: ['node']
+					}),
+					// @ts-ignore https://github.com/rollup/plugins/issues/1329
+					commonjs({ strictRequires: true }),
+					// @ts-ignore https://github.com/rollup/plugins/issues/1329
+					json()
+				]
+			});
+
+			await bundle.write({
+				dir: `${out}/server`,
+				format: 'esm',
+				sourcemap: true,
+				chunkFileNames: 'chunks/[name]-[hash].js'
+			});
+
+			builder.copy(files, out, {
+				replace: {
+					ENV: './env.js',
+					HANDLER: './handler.js',
+					MANIFEST: './server/manifest.js',
+					SERVER: './server/index.js',
+					SHIMS: './shims.js',
+					ENV_PREFIX: JSON.stringify(envPrefix)
+				}
+			});
+		},
+
+		supports: {
+			read: () => true
+		}
+	};
+}
diff --git a/node_modules/@sveltejs/adapter-node/.dfeddeedc9cbfffc-00000001.handler.js b/node_modules/@sveltejs/adapter-node/.dfeddeedc9cbfffc-00000001.handler.js
new file mode 100644
index 0000000..40d5245
--- /dev/null
+++ b/node_modules/@sveltejs/adapter-node/.dfeddeedc9cbfffc-00000001.handler.js
@@ -0,0 +1,1353 @@
+import 'SHIMS';
+import fs$1, { createReadStream } from 'node:fs';
+import path from 'node:path';
+import * as fs from 'fs';
+import { readdirSync, statSync } from 'fs';
+import { resolve, join, normalize } from 'path';
+import * as qs from 'querystring';
+import { fileURLToPath } from 'node:url';
+import { Readable } from 'node:stream';
+import { Server } from 'SERVER';
+import { manifest, prerendered, base } from 'MANIFEST';
+import { env } from 'ENV';
+
+function totalist(dir, callback, pre='') {
+	dir = resolve('.', dir);
+	let arr = readdirSync(dir);
+	let i=0, abs, stats;
+	for (; i < arr.length; i++) {
+		abs = join(dir, arr[i]);
+		stats = statSync(abs);
+		stats.isDirectory()
+			? totalist(abs, callback, join(pre, arr[i]))
+			: callback(join(pre, arr[i]), abs, stats);
+	}
+}
+
+/**
+ * @typedef ParsedURL
+ * @type {import('.').ParsedURL}
+ */
+
+/**
+ * @typedef Request
+ * @property {string} url
+ * @property {ParsedURL} _parsedUrl
+ */
+
+/**
+ * @param {Request} req
+ * @returns {ParsedURL|void}
+ */
+function parse$1(req) {
+	let raw = req.url;
+	if (raw == null) return;
+
+	let prev = req._parsedUrl;
+	if (prev && prev.raw === raw) return prev;
+
+	let pathname=raw, search='', query;
+
+	if (raw.length > 1) {
+		let idx = raw.indexOf('?', 1);
+
+		if (idx !== -1) {
+			search = raw.substring(idx);
+			pathname = raw.substring(0, idx);
+			if (search.length > 1) {
+				query = qs.parse(search.substring(1));
+			}
+		}
+	}
+
+	return req._parsedUrl = { pathname, search, query, raw };
+}
+
+const mimes = {
+  "3g2": "video/3gpp2",
+  "3gp": "video/3gpp",
+  "3gpp": "video/3gpp",
+  "3mf": "model/3mf",
+  "aac": "audio/aac",
+  "ac": "application/pkix-attr-cert",
+  "adp": "audio/adpcm",
+  "adts": "audio/aac",
+  "ai": "application/postscript",
+  "aml": "application/automationml-aml+xml",
+  "amlx": "application/automationml-amlx+zip",
+  "amr": "audio/amr",
+  "apng": "image/apng",
+  "appcache": "text/cache-manifest",
+  "appinstaller": "application/appinstaller",
+  "appx": "application/appx",
+  "appxbundle": "application/appxbundle",
+  "asc": "application/pgp-keys",
+  "atom": "application/atom+xml",
+  "atomcat": "application/atomcat+xml",
+  "atomdeleted": "application/atomdeleted+xml",
+  "atomsvc": "application/atomsvc+xml",
+  "au": "audio/basic",
+  "avci": "image/avci",
+  "avcs": "image/avcs",
+  "avif": "image/avif",
+  "aw": "application/applixware",
+  "bdoc": "application/bdoc",
+  "bin": "application/octet-stream",
+  "bmp": "image/bmp",
+  "bpk": "application/octet-stream",
+  "btf": "image/prs.btif",
+  "btif": "image/prs.btif",
+  "buffer": "application/octet-stream",
+  "ccxml": "application/ccxml+xml",
+  "cdfx": "application/cdfx+xml",
+  "cdmia": "application/cdmi-capability",
+  "cdmic": "application/cdmi-container",
+  "cdmid": "application/cdmi-domain",
+  "cdmio": "application/cdmi-object",
+  "cdmiq": "application/cdmi-queue",
+  "cer": "application/pkix-cert",
+  "cgm": "image/cgm",
+  "cjs": "application/node",
+  "class": "application/java-vm",
+  "coffee": "text/coffeescript",
+  "conf": "text/plain",
+  "cpl": "application/cpl+xml",
+  "cpt": "application/mac-compactpro",
+  "crl": "application/pkix-crl",
+  "css": "text/css",
+  "csv": "text/csv",
+  "cu": "application/cu-seeme",
+  "cwl": "application/cwl",
+  "cww": "application/prs.cww",
+  "davmount": "application/davmount+xml",
+  "dbk": "application/docbook+xml",
+  "deb": "application/octet-stream",
+  "def": "text/plain",
+  "deploy": "application/octet-stream",
+  "dib": "image/bmp",
+  "disposition-notification": "message/disposition-notification",
+  "dist": "application/octet-stream",
+  "distz": "application/octet-stream",
+  "dll": "application/octet-stream",
+  "dmg": "application/octet-stream",
+  "dms": "application/octet-stream",
+  "doc": "application/msword",
+  "dot": "application/msword",
+  "dpx": "image/dpx",
+  "drle": "image/dicom-rle",
+  "dsc": "text/prs.lines.tag",
+  "dssc": "application/dssc+der",
+  "dtd": "application/xml-dtd",
+  "dump": "application/octet-stream",
+  "dwd": "application/atsc-dwd+xml",
+  "ear": "application/java-archive",
+  "ecma": "application/ecmascript",
+  "elc": "application/octet-stream",
+  "emf": "image/emf",
+  "eml": "message/rfc822",
+  "emma": "application/emma+xml",
+  "emotionml": "application/emotionml+xml",
+  "eps": "application/postscript",
+  "epub": "application/epub+zip",
+  "exe": "application/octet-stream",
+  "exi": "application/exi",
+  "exp": "application/express",
+  "exr": "image/aces",
+  "ez": "application/andrew-inset",
+  "fdf": "application/fdf",
+  "fdt": "application/fdt+xml",
+  "fits": "image/fits",
+  "g3": "image/g3fax",
+  "gbr": "application/rpki-ghostbusters",
+  "geojson": "application/geo+json",
+  "gif": "image/gif",
+  "glb": "model/gltf-binary",
+  "gltf": "model/gltf+json",
+  "gml": "application/gml+xml",
+  "gpx": "application/gpx+xml",
+  "gram": "application/srgs",
+  "grxml": "application/srgs+xml",
+  "gxf": "application/gxf",
+  "gz": "application/gzip",
+  "h261": "video/h261",
+  "h263": "video/h263",
+  "h264": "video/h264",
+  "heic": "image/heic",
+  "heics": "image/heic-sequence",
+  "heif": "image/heif",
+  "heifs": "image/heif-sequence",
+  "hej2": "image/hej2k",
+  "held": "application/atsc-held+xml",
+  "hjson": "application/hjson",
+  "hlp": "application/winhlp",
+  "hqx": "application/mac-binhex40",
+  "hsj2": "image/hsj2",
+  "htm": "text/html",
+  "html": "text/html",
+  "ics": "text/calendar",
+  "ief": "image/ief",
+  "ifb": "text/calendar",
+  "iges": "model/iges",
+  "igs": "model/iges",
+  "img": "application/octet-stream",
+  "in": "text/plain",
+  "ini": "text/plain",
+  "ink": "application/inkml+xml",
+  "inkml": "application/inkml+xml",
+  "ipfix": "application/ipfix",
+  "iso": "application/octet-stream",
+  "its": "application/its+xml",
+  "jade": "text/jade",
+  "jar": "application/java-archive",
+  "jhc": "image/jphc",
+  "jls": "image/jls",
+  "jp2": "image/jp2",
+  "jpe": "image/jpeg",
+  "jpeg": "image/jpeg",
+  "jpf": "image/jpx",
+  "jpg": "image/jpeg",
+  "jpg2": "image/jp2",
+  "jpgm": "image/jpm",
+  "jpgv": "video/jpeg",
+  "jph": "image/jph",
+  "jpm": "image/jpm",
+  "jpx": "image/jpx",
+  "js": "text/javascript",
+  "json": "application/json",
+  "json5": "application/json5",
+  "jsonld": "application/ld+json",
+  "jsonml": "application/jsonml+json",
+  "jsx": "text/jsx",
+  "jt": "model/jt",
+  "jxr": "image/jxr",
+  "jxra": "image/jxra",
+  "jxrs": "image/jxrs",
+  "jxs": "image/jxs",
+  "jxsc": "image/jxsc",
+  "jxsi": "image/jxsi",
+  "jxss": "image/jxss",
+  "kar": "audio/midi",
+  "ktx": "image/ktx",
+  "ktx2": "image/ktx2",
+  "less": "text/less",
+  "lgr": "application/lgr+xml",
+  "list": "text/plain",
+  "litcoffee": "text/coffeescript",
+  "log": "text/plain",
+  "lostxml": "application/lost+xml",
+  "lrf": "application/octet-stream",
+  "m1v": "video/mpeg",
+  "m21": "application/mp21",
+  "m2a": "audio/mpeg",
+  "m2v": "video/mpeg",
+  "m3a": "audio/mpeg",
+  "m4a": "audio/mp4",
+  "m4p": "application/mp4",
+  "m4s": "video/iso.segment",
+  "ma": "application/mathematica",
+  "mads": "application/mads+xml",
+  "maei": "application/mmt-aei+xml",
+  "man": "text/troff",
+  "manifest": "text/cache-manifest",
+  "map": "application/json",
+  "mar": "application/octet-stream",
+  "markdown": "text/markdown",
+  "mathml": "application/mathml+xml",
+  "mb": "application/mathematica",
+  "mbox": "application/mbox",
+  "md": "text/markdown",
+  "mdx": "text/mdx",
+  "me": "text/troff",
+  "mesh": "model/mesh",
+  "meta4": "application/metalink4+xml",
+  "metalink": "application/metalink+xml",
+  "mets": "application/mets+xml",
+  "mft": "application/rpki-manifest",
+  "mid": "audio/midi",
+  "midi": "audio/midi",
+  "mime": "message/rfc822",
+  "mj2": "video/mj2",
+  "mjp2": "video/mj2",
+  "mjs": "text/javascript",
+  "mml": "text/mathml",
+  "mods": "application/mods+xml",
+  "mov": "video/quicktime",
+  "mp2": "audio/mpeg",
+  "mp21": "application/mp21",
+  "mp2a": "audio/mpeg",
+  "mp3": "audio/mpeg",
+  "mp4": "video/mp4",
+  "mp4a": "audio/mp4",
+  "mp4s": "application/mp4",
+  "mp4v": "video/mp4",
+  "mpd": "application/dash+xml",
+  "mpe": "video/mpeg",
+  "mpeg": "video/mpeg",
+  "mpf": "application/media-policy-dataset+xml",
+  "mpg": "video/mpeg",
+  "mpg4": "video/mp4",
+  "mpga": "audio/mpeg",
+  "mpp": "application/dash-patch+xml",
+  "mrc": "application/marc",
+  "mrcx": "application/marcxml+xml",
+  "ms": "text/troff",
+  "mscml": "application/mediaservercontrol+xml",
+  "msh": "model/mesh",
+  "msi": "application/octet-stream",
+  "msix": "application/msix",
+  "msixbundle": "application/msixbundle",
+  "msm": "application/octet-stream",
+  "msp": "application/octet-stream",
+  "mtl": "model/mtl",
+  "musd": "application/mmt-usd+xml",
+  "mxf": "application/mxf",
+  "mxmf": "audio/mobile-xmf",
+  "mxml": "application/xv+xml",
+  "n3": "text/n3",
+  "nb": "application/mathematica",
+  "nq": "application/n-quads",
+  "nt": "application/n-triples",
+  "obj": "model/obj",
+  "oda": "application/oda",
+  "oga": "audio/ogg",
+  "ogg": "audio/ogg",
+  "ogv": "video/ogg",
+  "ogx": "application/ogg",
+  "omdoc": "application/omdoc+xml",
+  "onepkg": "application/onenote",
+  "onetmp": "application/onenote",
+  "onetoc": "application/onenote",
+  "onetoc2": "application/onenote",
+  "opf": "application/oebps-package+xml",
+  "opus": "audio/ogg",
+  "otf": "font/otf",
+  "owl": "application/rdf+xml",
+  "oxps": "application/oxps",
+  "p10": "application/pkcs10",
+  "p7c": "application/pkcs7-mime",
+  "p7m": "application/pkcs7-mime",
+  "p7s": "application/pkcs7-signature",
+  "p8": "application/pkcs8",
+  "pdf": "application/pdf",
+  "pfr": "application/font-tdpfr",
+  "pgp": "application/pgp-encrypted",
+  "pkg": "application/octet-stream",
+  "pki": "application/pkixcmp",
+  "pkipath": "application/pkix-pkipath",
+  "pls": "application/pls+xml",
+  "png": "image/png",
+  "prc": "model/prc",
+  "prf": "application/pics-rules",
+  "provx": "application/provenance+xml",
+  "ps": "application/postscript",
+  "pskcxml": "application/pskc+xml",
+  "pti": "image/prs.pti",
+  "qt": "video/quicktime",
+  "raml": "application/raml+yaml",
+  "rapd": "application/route-apd+xml",
+  "rdf": "application/rdf+xml",
+  "relo": "application/p2p-overlay+xml",
+  "rif": "application/reginfo+xml",
+  "rl": "application/resource-lists+xml",
+  "rld": "application/resource-lists-diff+xml",
+  "rmi": "audio/midi",
+  "rnc": "application/relax-ng-compact-syntax",
+  "rng": "application/xml",
+  "roa": "application/rpki-roa",
+  "roff": "text/troff",
+  "rq": "application/sparql-query",
+  "rs": "application/rls-services+xml",
+  "rsat": "application/atsc-rsat+xml",
+  "rsd": "application/rsd+xml",
+  "rsheet": "application/urc-ressheet+xml",
+  "rss": "application/rss+xml",
+  "rtf": "text/rtf",
+  "rtx": "text/richtext",
+  "rusd": "application/route-usd+xml",
+  "s3m": "audio/s3m",
+  "sbml": "application/sbml+xml",
+  "scq": "application/scvp-cv-request",
+  "scs": "application/scvp-cv-response",
+  "sdp": "application/sdp",
+  "senmlx": "application/senml+xml",
+  "sensmlx": "application/sensml+xml",
+  "ser": "application/java-serialized-object",
+  "setpay": "application/set-payment-initiation",
+  "setreg": "application/set-registration-initiation",
+  "sgi": "image/sgi",
+  "sgm": "text/sgml",
+  "sgml": "text/sgml",
+  "shex": "text/shex",
+  "shf": "application/shf+xml",
+  "shtml": "text/html",
+  "sieve": "application/sieve",
+  "sig": "application/pgp-signature",
+  "sil": "audio/silk",
+  "silo": "model/mesh",
+  "siv": "application/sieve",
+  "slim": "text/slim",
+  "slm": "text/slim",
+  "sls": "application/route-s-tsid+xml",
+  "smi": "application/smil+xml",
+  "smil": "application/smil+xml",
+  "snd": "audio/basic",
+  "so": "application/octet-stream",
+  "spdx": "text/spdx",
+  "spp": "application/scvp-vp-response",
+  "spq": "application/scvp-vp-request",
+  "spx": "audio/ogg",
+  "sql": "application/sql",
+  "sru": "application/sru+xml",
+  "srx": "application/sparql-results+xml",
+  "ssdl": "application/ssdl+xml",
+  "ssml": "application/ssml+xml",
+  "stk": "application/hyperstudio",
+  "stl": "model/stl",
+  "stpx": "model/step+xml",
+  "stpxz": "model/step-xml+zip",
+  "stpz": "model/step+zip",
+  "styl": "text/stylus",
+  "stylus": "text/stylus",
+  "svg": "image/svg+xml",
+  "svgz": "image/svg+xml",
+  "swidtag": "application/swid+xml",
+  "t": "text/troff",
+  "t38": "image/t38",
+  "td": "application/urc-targetdesc+xml",
+  "tei": "application/tei+xml",
+  "teicorpus": "application/tei+xml",
+  "text": "text/plain",
+  "tfi": "application/thraud+xml",
+  "tfx": "image/tiff-fx",
+  "tif": "image/tiff",
+  "tiff": "image/tiff",
+  "toml": "application/toml",
+  "tr": "text/troff",
+  "trig": "application/trig",
+  "ts": "video/mp2t",
+  "tsd": "application/timestamped-data",
+  "tsv": "text/tab-separated-values",
+  "ttc": "font/collection",
+  "ttf": "font/ttf",
+  "ttl": "text/turtle",
+  "ttml": "application/ttml+xml",
+  "txt": "text/plain",
+  "u3d": "model/u3d",
+  "u8dsn": "message/global-delivery-status",
+  "u8hdr": "message/global-headers",
+  "u8mdn": "message/global-disposition-notification",
+  "u8msg": "message/global",
+  "ubj": "application/ubjson",
+  "uri": "text/uri-list",
+  "uris": "text/uri-list",
+  "urls": "text/uri-list",
+  "vcard": "text/vcard",
+  "vrml": "model/vrml",
+  "vtt": "text/vtt",
+  "vxml": "application/voicexml+xml",
+  "war": "application/java-archive",
+  "wasm": "application/wasm",
+  "wav": "audio/wav",
+  "weba": "audio/webm",
+  "webm": "video/webm",
+  "webmanifest": "application/manifest+json",
+  "webp": "image/webp",
+  "wgsl": "text/wgsl",
+  "wgt": "application/widget",
+  "wif": "application/watcherinfo+xml",
+  "wmf": "image/wmf",
+  "woff": "font/woff",
+  "woff2": "font/woff2",
+  "wrl": "model/vrml",
+  "wsdl": "application/wsdl+xml",
+  "wspolicy": "application/wspolicy+xml",
+  "x3d": "model/x3d+xml",
+  "x3db": "model/x3d+fastinfoset",
+  "x3dbz": "model/x3d+binary",
+  "x3dv": "model/x3d-vrml",
+  "x3dvz": "model/x3d+vrml",
+  "x3dz": "model/x3d+xml",
+  "xaml": "application/xaml+xml",
+  "xav": "application/xcap-att+xml",
+  "xca": "application/xcap-caps+xml",
+  "xcs": "application/calendar+xml",
+  "xdf": "application/xcap-diff+xml",
+  "xdssc": "application/dssc+xml",
+  "xel": "application/xcap-el+xml",
+  "xenc": "application/xenc+xml",
+  "xer": "application/patch-ops-error+xml",
+  "xfdf": "application/xfdf",
+  "xht": "application/xhtml+xml",
+  "xhtml": "application/xhtml+xml",
+  "xhvml": "application/xv+xml",
+  "xlf": "application/xliff+xml",
+  "xm": "audio/xm",
+  "xml": "text/xml",
+  "xns": "application/xcap-ns+xml",
+  "xop": "application/xop+xml",
+  "xpl": "application/xproc+xml",
+  "xsd": "application/xml",
+  "xsf": "application/prs.xsf+xml",
+  "xsl": "application/xml",
+  "xslt": "application/xml",
+  "xspf": "application/xspf+xml",
+  "xvm": "application/xv+xml",
+  "xvml": "application/xv+xml",
+  "yaml": "text/yaml",
+  "yang": "application/yang",
+  "yin": "application/yin+xml",
+  "yml": "text/yaml",
+  "zip": "application/zip"
+};
+
+function lookup(extn) {
+	let tmp = ('' + extn).trim().toLowerCase();
+	let idx = tmp.lastIndexOf('.');
+	return mimes[!~idx ? tmp : tmp.substring(++idx)];
+}
+
+const noop = () => {};
+
+function isMatch(uri, arr) {
+	for (let i=0; i < arr.length; i++) {
+		if (arr[i].test(uri)) return true;
+	}
+}
+
+function toAssume(uri, extns) {
+	let i=0, x, len=uri.length - 1;
+	if (uri.charCodeAt(len) === 47) {
+		uri = uri.substring(0, len);
+	}
+
+	let arr=[], tmp=`${uri}/index`;
+	for (; i < extns.length; i++) {
+		x = extns[i] ? `.${extns[i]}` : '';
+		if (uri) arr.push(uri + x);
+		arr.push(tmp + x);
+	}
+
+	return arr;
+}
+
+function viaCache(cache, uri, extns) {
+	let i=0, data, arr=toAssume(uri, extns);
+	for (; i < arr.length; i++) {
+		if (data = cache[arr[i]]) return data;
+	}
+}
+
+function viaLocal(dir, isEtag, uri, extns) {
+	let i=0, arr=toAssume(uri, extns);
+	let abs, stats, name, headers;
+	for (; i < arr.length; i++) {
+		abs = normalize(join(dir, name=arr[i]));
+		if (abs.startsWith(dir) && fs.existsSync(abs)) {
+			stats = fs.statSync(abs);
+			if (stats.isDirectory()) continue;
+			headers = toHeaders(name, stats, isEtag);
+			headers['Cache-Control'] = isEtag ? 'no-cache' : 'no-store';
+			return { abs, stats, headers };
+		}
+	}
+}
+
+function is404(req, res) {
+	return (res.statusCode=404,res.end());
+}
+
+function send(req, res, file, stats, headers) {
+	let code=200, tmp, opts={};
+	headers = { ...headers };
+
+	for (let key in headers) {
+		tmp = res.getHeader(key);
+		if (tmp) headers[key] = tmp;
+	}
+
+	if (tmp = res.getHeader('content-type')) {
+		headers['Content-Type'] = tmp;
+	}
+
+	if (req.headers.range) {
+		code = 206;
+		let [x, y] = req.headers.range.replace('bytes=', '').split('-');
+		let end = opts.end = parseInt(y, 10) || stats.size - 1;
+		let start = opts.start = parseInt(x, 10) || 0;
+
+		if (end >= stats.size) {
+			end = stats.size - 1;
+		}
+
+		if (start >= stats.size) {
+			res.setHeader('Content-Range', `bytes */${stats.size}`);
+			res.statusCode = 416;
+			return res.end();
+		}
+
+		headers['Content-Range'] = `bytes ${start}-${end}/${stats.size}`;
+		headers['Content-Length'] = (end - start + 1);
+		headers['Accept-Ranges'] = 'bytes';
+	}
+
+	res.writeHead(code, headers);
+	fs.createReadStream(file, opts).pipe(res);
+}
+
+const ENCODING = {
+	'.br': 'br',
+	'.gz': 'gzip',
+};
+
+function toHeaders(name, stats, isEtag) {
+	let enc = ENCODING[name.slice(-3)];
+
+	let ctype = lookup(name.slice(0, enc && -3)) || '';
+	if (ctype === 'text/html') ctype += ';charset=utf-8';
+
+	let headers = {
+		'Content-Length': stats.size,
+		'Content-Type': ctype,
+		'Last-Modified': stats.mtime.toUTCString(),
+	};
+
+	if (enc) headers['Content-Encoding'] = enc;
+	if (isEtag) headers['ETag'] = `W/"${stats.size}-${stats.mtime.getTime()}"`;
+
+	return headers;
+}
+
+function sirv (dir, opts={}) {
+	dir = resolve(dir || '.');
+
+	let isNotFound = opts.onNoMatch || is404;
+	let setHeaders = opts.setHeaders || noop;
+
+	let extensions = opts.extensions || ['html', 'htm'];
+	let gzips = opts.gzip && extensions.map(x => `${x}.gz`).concat('gz');
+	let brots = opts.brotli && extensions.map(x => `${x}.br`).concat('br');
+
+	const FILES = {};
+
+	let fallback = '/';
+	let isEtag = !!opts.etag;
+	let isSPA = !!opts.single;
+	if (typeof opts.single === 'string') {
+		let idx = opts.single.lastIndexOf('.');
+		fallback += !!~idx ? opts.single.substring(0, idx) : opts.single;
+	}
+
+	let ignores = [];
+	if (opts.ignores !== false) {
+		ignores.push(/[/]([A-Za-z\s\d~$._-]+\.\w+){1,}$/); // any extn
+		if (opts.dotfiles) ignores.push(/\/\.\w/);
+		else ignores.push(/\/\.well-known/);
+		[].concat(opts.ignores || []).forEach(x => {
+			ignores.push(new RegExp(x, 'i'));
+		});
+	}
+
+	let cc = opts.maxAge != null && `public,max-age=${opts.maxAge}`;
+	if (cc && opts.immutable) cc += ',immutable';
+	else if (cc && opts.maxAge === 0) cc += ',must-revalidate';
+
+	if (!opts.dev) {
+		totalist(dir, (name, abs, stats) => {
+			if (/\.well-known[\\+\/]/.test(name)) ; // keep
+			else if (!opts.dotfiles && /(^\.|[\\+|\/+]\.)/.test(name)) return;
+
+			let headers = toHeaders(name, stats, isEtag);
+			if (cc) headers['Cache-Control'] = cc;
+
+			FILES['/' + name.normalize().replace(/\\+/g, '/')] = { abs, stats, headers };
+		});
+	}
+
+	let lookup = opts.dev ? viaLocal.bind(0, dir, isEtag) : viaCache.bind(0, FILES);
+
+	return function (req, res, next) {
+		let extns = [''];
+		let pathname = parse$1(req).pathname;
+		let val = req.headers['accept-encoding'] || '';
+		if (gzips && val.includes('gzip')) extns.unshift(...gzips);
+		if (brots && /(br|brotli)/i.test(val)) extns.unshift(...brots);
+		extns.push(...extensions); // [...br, ...gz, orig, ...exts]
+
+		if (pathname.indexOf('%') !== -1) {
+			try { pathname = decodeURI(pathname); }
+			catch (err) { /* malform uri */ }
+		}
+
+		let data = lookup(pathname, extns) || isSPA && !isMatch(pathname, ignores) && lookup(fallback, extns);
+		if (!data) return next ? next() : isNotFound(req, res);
+
+		if (isEtag && req.headers['if-none-match'] === data.headers['ETag']) {
+			res.writeHead(304);
+			return res.end();
+		}
+
+		if (gzips || brots) {
+			res.setHeader('Vary', 'Accept-Encoding');
+		}
+
+		setHeaders(res, pathname, data.stats);
+		send(req, res, data.abs, data.stats, data.headers);
+	};
+}
+
+var setCookie = {exports: {}};
+
+var defaultParseOptions = {
+  decodeValues: true,
+  map: false,
+  silent: false,
+};
+
+function isNonEmptyString(str) {
+  return typeof str === "string" && !!str.trim();
+}
+
+function parseString(setCookieValue, options) {
+  var parts = setCookieValue.split(";").filter(isNonEmptyString);
+
+  var nameValuePairStr = parts.shift();
+  var parsed = parseNameValuePair(nameValuePairStr);
+  var name = parsed.name;
+  var value = parsed.value;
+
+  options = options
+    ? Object.assign({}, defaultParseOptions, options)
+    : defaultParseOptions;
+
+  try {
+    value = options.decodeValues ? decodeURIComponent(value) : value; // decode cookie value
+  } catch (e) {
+    console.error(
+      "set-cookie-parser encountered an error while decoding a cookie with value '" +
+        value +
+        "'. Set options.decodeValues to false to disable this feature.",
+      e
+    );
+  }
+
+  var cookie = {
+    name: name,
+    value: value,
+  };
+
+  parts.forEach(function (part) {
+    var sides = part.split("=");
+    var key = sides.shift().trimLeft().toLowerCase();
+    var value = sides.join("=");
+    if (key === "expires") {
+      cookie.expires = new Date(value);
+    } else if (key === "max-age") {
+      cookie.maxAge = parseInt(value, 10);
+    } else if (key === "secure") {
+      cookie.secure = true;
+    } else if (key === "httponly") {
+      cookie.httpOnly = true;
+    } else if (key === "samesite") {
+      cookie.sameSite = value;
+    } else {
+      cookie[key] = value;
+    }
+  });
+
+  return cookie;
+}
+
+function parseNameValuePair(nameValuePairStr) {
+  // Parses name-value-pair according to rfc6265bis draft
+
+  var name = "";
+  var value = "";
+  var nameValueArr = nameValuePairStr.split("=");
+  if (nameValueArr.length > 1) {
+    name = nameValueArr.shift();
+    value = nameValueArr.join("="); // everything after the first =, joined by a "=" if there was more than one part
+  } else {
+    value = nameValuePairStr;
+  }
+
+  return { name: name, value: value };
+}
+
+function parse(input, options) {
+  options = options
+    ? Object.assign({}, defaultParseOptions, options)
+    : defaultParseOptions;
+
+  if (!input) {
+    if (!options.map) {
+      return [];
+    } else {
+      return {};
+    }
+  }
+
+  if (input.headers) {
+    if (typeof input.headers.getSetCookie === "function") {
+      // for fetch responses - they combine headers of the same type in the headers array,
+      // but getSetCookie returns an uncombined array
+      input = input.headers.getSetCookie();
+    } else if (input.headers["set-cookie"]) {
+      // fast-path for node.js (which automatically normalizes header names to lower-case
+      input = input.headers["set-cookie"];
+    } else {
+      // slow-path for other environments - see #25
+      var sch =
+        input.headers[
+          Object.keys(input.headers).find(function (key) {
+            return key.toLowerCase() === "set-cookie";
+          })
+        ];
+      // warn if called on a request-like object with a cookie header rather than a set-cookie header - see #34, 36
+      if (!sch && input.headers.cookie && !options.silent) {
+        console.warn(
+          "Warning: set-cookie-parser appears to have been called on a request object. It is designed to parse Set-Cookie headers from responses, not Cookie headers from requests. Set the option {silent: true} to suppress this warning."
+        );
+      }
+      input = sch;
+    }
+  }
+  if (!Array.isArray(input)) {
+    input = [input];
+  }
+
+  options = options
+    ? Object.assign({}, defaultParseOptions, options)
+    : defaultParseOptions;
+
+  if (!options.map) {
+    return input.filter(isNonEmptyString).map(function (str) {
+      return parseString(str, options);
+    });
+  } else {
+    var cookies = {};
+    return input.filter(isNonEmptyString).reduce(function (cookies, str) {
+      var cookie = parseString(str, options);
+      cookies[cookie.name] = cookie;
+      return cookies;
+    }, cookies);
+  }
+}
+
+/*
+  Set-Cookie header field-values are sometimes comma joined in one string. This splits them without choking on commas
+  that are within a single set-cookie field-value, such as in the Expires portion.
+
+  This is uncommon, but explicitly allowed - see https://tools.ietf.org/html/rfc2616#section-4.2
+  Node.js does this for every header *except* set-cookie - see https://github.com/nodejs/node/blob/d5e363b77ebaf1caf67cd7528224b651c86815c1/lib/_http_incoming.js#L128
+  React Native's fetch does this for *every* header, including set-cookie.
+
+  Based on: https://github.com/google/j2objc/commit/16820fdbc8f76ca0c33472810ce0cb03d20efe25
+  Credits to: https://github.com/tomball for original and https://github.com/chrusart for JavaScript implementation
+*/
+function splitCookiesString(cookiesString) {
+  if (Array.isArray(cookiesString)) {
+    return cookiesString;
+  }
+  if (typeof cookiesString !== "string") {
+    return [];
+  }
+
+  var cookiesStrings = [];
+  var pos = 0;
+  var start;
+  var ch;
+  var lastComma;
+  var nextStart;
+  var cookiesSeparatorFound;
+
+  function skipWhitespace() {
+    while (pos < cookiesString.length && /\s/.test(cookiesString.charAt(pos))) {
+      pos += 1;
+    }
+    return pos < cookiesString.length;
+  }
+
+  function notSpecialChar() {
+    ch = cookiesString.charAt(pos);
+
+    return ch !== "=" && ch !== ";" && ch !== ",";
+  }
+
+  while (pos < cookiesString.length) {
+    start = pos;
+    cookiesSeparatorFound = false;
+
+    while (skipWhitespace()) {
+      ch = cookiesString.charAt(pos);
+      if (ch === ",") {
+        // ',' is a cookie separator if we have later first '=', not ';' or ','
+        lastComma = pos;
+        pos += 1;
+
+        skipWhitespace();
+        nextStart = pos;
+
+        while (pos < cookiesString.length && notSpecialChar()) {
+          pos += 1;
+        }
+
+        // currently special character
+        if (pos < cookiesString.length && cookiesString.charAt(pos) === "=") {
+          // we found cookies separator
+          cookiesSeparatorFound = true;
+          // pos is inside the next cookie, so back up and return it.
+          pos = nextStart;
+          cookiesStrings.push(cookiesString.substring(start, lastComma));
+          start = pos;
+        } else {
+          // in param ',' or param separator ';',
+          // we continue from that comma
+          pos = lastComma + 1;
+        }
+      } else {
+        pos += 1;
+      }
+    }
+
+    if (!cookiesSeparatorFound || pos >= cookiesString.length) {
+      cookiesStrings.push(cookiesString.substring(start, cookiesString.length));
+    }
+  }
+
+  return cookiesStrings;
+}
+
+setCookie.exports = parse;
+setCookie.exports.parse = parse;
+setCookie.exports.parseString = parseString;
+var splitCookiesString_1 = setCookie.exports.splitCookiesString = splitCookiesString;
+
+/**
+ * An error that was thrown from within the SvelteKit runtime that is not fatal and doesn't result in a 500, such as a 404.
+ * `SvelteKitError` goes through `handleError`.
+ * @extends Error
+ */
+class SvelteKitError extends Error {
+	/**
+	 * @param {number} status
+	 * @param {string} text
+	 * @param {string} message
+	 */
+	constructor(status, text, message) {
+		super(message);
+		this.status = status;
+		this.text = text;
+	}
+}
+
+/**
+ * @param {import('http').IncomingMessage} req
+ * @param {number} [body_size_limit]
+ */
+function get_raw_body(req, body_size_limit) {
+	const h = req.headers;
+
+	if (!h['content-type']) {
+		return null;
+	}
+
+	const content_length = Number(h['content-length']);
+
+	// check if no request body
+	if (
+		(req.httpVersionMajor === 1 && isNaN(content_length) && h['transfer-encoding'] == null) ||
+		content_length === 0
+	) {
+		return null;
+	}
+
+	if (req.destroyed) {
+		const readable = new ReadableStream();
+		readable.cancel();
+		return readable;
+	}
+
+	let size = 0;
+	let cancelled = false;
+
+	return new ReadableStream({
+		start(controller) {
+			if (body_size_limit !== undefined && content_length > body_size_limit) {
+				let message = `Content-length of ${content_length} exceeds limit of ${body_size_limit} bytes.`;
+
+				if (body_size_limit === 0) {
+					// https://github.com/sveltejs/kit/pull/11589
+					// TODO this exists to aid migration — remove in a future version
+					message += ' To disable body size limits, specify Infinity rather than 0.';
+				}
+
+				const error = new SvelteKitError(413, 'Payload Too Large', message);
+
+				controller.error(error);
+				return;
+			}
+
+			req.on('error', (error) => {
+				cancelled = true;
+				controller.error(error);
+			});
+
+			req.on('end', () => {
+				if (cancelled) return;
+				controller.close();
+			});
+
+			req.on('data', (chunk) => {
+				if (cancelled) return;
+
+				size += chunk.length;
+				if (size > content_length) {
+					cancelled = true;
+
+					const constraint = content_length ? 'content-length' : 'BODY_SIZE_LIMIT';
+					const message = `request body size exceeded ${constraint} of ${content_length}`;
+
+					const error = new SvelteKitError(413, 'Payload Too Large', message);
+					controller.error(error);
+
+					return;
+				}
+
+				controller.enqueue(chunk);
+
+				if (controller.desiredSize === null || controller.desiredSize <= 0) {
+					req.pause();
+				}
+			});
+		},
+
+		pull() {
+			req.resume();
+		},
+
+		cancel(reason) {
+			cancelled = true;
+			req.destroy(reason);
+		}
+	});
+}
+
+/**
+ * @param {{
+ *   request: import('http').IncomingMessage;
+ *   base: string;
+ *   bodySizeLimit?: number;
+ * }} options
+ * @returns {Promise<Request>}
+ */
+// TODO 3.0 make the signature synchronous?
+// eslint-disable-next-line @typescript-eslint/require-await
+async function getRequest({ request, base, bodySizeLimit }) {
+	return new Request(base + request.url, {
+		// @ts-expect-error
+		duplex: 'half',
+		method: request.method,
+		headers: /** @type {Record<string, string>} */ (request.headers),
+		body:
+			request.method === 'GET' || request.method === 'HEAD'
+				? undefined
+				: get_raw_body(request, bodySizeLimit)
+	});
+}
+
+/**
+ * @param {import('http').ServerResponse} res
+ * @param {Response} response
+ * @returns {Promise<void>}
+ */
+// TODO 3.0 make the signature synchronous?
+// eslint-disable-next-line @typescript-eslint/require-await
+async function setResponse(res, response) {
+	for (const [key, value] of response.headers) {
+		try {
+			res.setHeader(
+				key,
+				key === 'set-cookie'
+					? splitCookiesString_1(
+							// This is absurd but necessary, TODO: investigate why
+							/** @type {string}*/ (response.headers.get(key))
+						)
+					: value
+			);
+		} catch (error) {
+			res.getHeaderNames().forEach((name) => res.removeHeader(name));
+			res.writeHead(500).end(String(error));
+			return;
+		}
+	}
+
+	res.writeHead(response.status);
+
+	if (!response.body) {
+		res.end();
+		return;
+	}
+
+	if (response.body.locked) {
+		res.end(
+			'Fatal error: Response body is locked. ' +
+				"This can happen when the response was already read (for example through 'response.json()' or 'response.text()')."
+		);
+		return;
+	}
+
+	const reader = response.body.getReader();
+
+	if (res.destroyed) {
+		reader.cancel();
+		return;
+	}
+
+	const cancel = (/** @type {Error|undefined} */ error) => {
+		res.off('close', cancel);
+		res.off('error', cancel);
+
+		// If the reader has already been interrupted with an error earlier,
+		// then it will appear here, it is useless, but it needs to be catch.
+		reader.cancel(error).catch(() => {});
+		if (error) res.destroy(error);
+	};
+
+	res.on('close', cancel);
+	res.on('error', cancel);
+
+	next();
+	async function next() {
+		try {
+			for (;;) {
+				const { done, value } = await reader.read();
+
+				if (done) break;
+
+				if (!res.write(value)) {
+					res.once('drain', next);
+					return;
+				}
+			}
+			res.end();
+		} catch (error) {
+			cancel(error instanceof Error ? error : new Error(String(error)));
+		}
+	}
+}
+
+/**
+ * Converts a file on disk to a readable stream
+ * @param {string} file
+ * @returns {ReadableStream}
+ * @since 2.4.0
+ */
+function createReadableStream(file) {
+	return /** @type {ReadableStream} */ (Readable.toWeb(createReadStream(file)));
+}
+
+/* global ENV_PREFIX */
+
+const server = new Server(manifest);
+
+const origin = env('ORIGIN', undefined);
+const xff_depth = parseInt(env('XFF_DEPTH', '1'));
+const address_header = env('ADDRESS_HEADER', '').toLowerCase();
+const protocol_header = env('PROTOCOL_HEADER', '').toLowerCase();
+const host_header = env('HOST_HEADER', 'host').toLowerCase();
+const port_header = env('PORT_HEADER', '').toLowerCase();
+
+/**
+ * @param {string} bytes
+ */
+function parse_body_size_limit(bytes) {
+	const multiplier =
+		{
+			K: 1024,
+			M: 1024 * 1024,
+			G: 1024 * 1024 * 1024
+		}[bytes[bytes.length - 1]?.toUpperCase()] ?? 1;
+	return Number(multiplier != 1 ? bytes.substring(0, bytes.length - 1) : bytes) * multiplier;
+}
+
+const body_size_limit = parse_body_size_limit(env('BODY_SIZE_LIMIT', '512K'));
+
+if (isNaN(body_size_limit)) {
+	throw new Error(
+		`Invalid BODY_SIZE_LIMIT: '${env('BODY_SIZE_LIMIT')}'. Please provide a numeric value.`
+	);
+}
+
+const dir = path.dirname(fileURLToPath(import.meta.url));
+
+const asset_dir = `${dir}/client${base}`;
+
+await server.init({
+	env: process.env,
+	read: (file) => createReadableStream(`${asset_dir}/${file}`)
+});
+
+/**
+ * @param {string} path
+ * @param {boolean} client
+ */
+function serve(path, client = false) {
+	return (
+		fs$1.existsSync(path) &&
+		sirv(path, {
+			etag: true,
+			gzip: true,
+			brotli: true,
+			setHeaders:
+				client &&
+				((res, pathname) => {
+					// only apply to build directory, not e.g. version.json
+					if (pathname.startsWith(`/${manifest.appPath}/immutable/`) && res.statusCode === 200) {
+						res.setHeader('cache-control', 'public,max-age=31536000,immutable');
+					}
+				})
+		})
+	);
+}
+
+// required because the static file server ignores trailing slashes
+/** @returns {import('polka').Middleware} */
+function serve_prerendered() {
+	const handler = serve(path.join(dir, 'prerendered'));
+
+	return (req, res, next) => {
+		let { pathname, search, query } = parse$1(req);
+
+		try {
+			pathname = decodeURIComponent(pathname);
+		} catch {
+			// ignore invalid URI
+		}
+
+		if (prerendered.has(pathname)) {
+			return handler(req, res, next);
+		}
+
+		// remove or add trailing slash as appropriate
+		let location = pathname.at(-1) === '/' ? pathname.slice(0, -1) : pathname + '/';
+		if (prerendered.has(location)) {
+			if (query) location += search;
+			res.writeHead(308, { location }).end();
+		} else {
+			next();
+		}
+	};
+}
+
+/** @type {import('polka').Middleware} */
+const ssr = async (req, res) => {
+	/** @type {Request} */
+	let request;
+
+	try {
+		request = await getRequest({
+			base: origin || get_origin(req.headers),
+			request: req,
+			bodySizeLimit: body_size_limit
+		});
+	} catch {
+		res.statusCode = 400;
+		res.end('Bad Request');
+		return;
+	}
+
+	setResponse(
+		res,
+		await server.respond(request, {
+			platform: { req },
+			getClientAddress: () => {
+				if (address_header) {
+					if (!(address_header in req.headers)) {
+						throw new Error(
+							`Address header was specified with ${
+								ENV_PREFIX + 'ADDRESS_HEADER'
+							}=${address_header} but is absent from request`
+						);
+					}
+
+					const value = /** @type {string} */ (req.headers[address_header]) || '';
+
+					if (address_header === 'x-forwarded-for') {
+						const addresses = value.split(',');
+
+						if (xff_depth < 1) {
+							throw new Error(`${ENV_PREFIX + 'XFF_DEPTH'} must be a positive integer`);
+						}
+
+						if (xff_depth > addresses.length) {
+							throw new Error(
+								`${ENV_PREFIX + 'XFF_DEPTH'} is ${xff_depth}, but only found ${
+									addresses.length
+								} addresses`
+							);
+						}
+						return addresses[addresses.length - xff_depth].trim();
+					}
+
+					return value;
+				}
+
+				return (
+					req.connection?.remoteAddress ||
+					// @ts-expect-error
+					req.connection?.socket?.remoteAddress ||
+					req.socket?.remoteAddress ||
+					// @ts-expect-error
+					req.info?.remoteAddress
+				);
+			}
+		})
+	);
+};
+
+/** @param {import('polka').Middleware[]} handlers */
+function sequence(handlers) {
+	/** @type {import('polka').Middleware} */
+	return (req, res, next) => {
+		/**
+		 * @param {number} i
+		 * @returns {ReturnType<import('polka').Middleware>}
+		 */
+		function handle(i) {
+			if (i < handlers.length) {
+				return handlers[i](req, res, () => handle(i + 1));
+			} else {
+				return next();
+			}
+		}
+
+		return handle(0);
+	};
+}
+
+/**
+ * @param {import('http').IncomingHttpHeaders} headers
+ * @returns
+ */
+function get_origin(headers) {
+	const protocol = (protocol_header && headers[protocol_header]) || 'https';
+	const host = headers[host_header];
+	const port = port_header && headers[port_header];
+	if (port) {
+		return `${protocol}://${host}:${port}`;
+	} else {
+		return `${protocol}://${host}`;
+	}
+}
+
+const handler = sequence(
+	[
+		serve(path.join(dir, 'client'), true),
+		serve(path.join(dir, 'static')),
+		serve(path.join(dir, 'fallback'), true),
+		serve_prerendered(),
+		ssr
+	].filter(Boolean)
+);
+
+export { handler };
diff --git a/node_modules/@sveltejs/adapter-node/.f7fdfefb7bf77fb4-00000006.LICENSE b/node_modules/@sveltejs/adapter-node/.f7fdfefb7bf77fb4-00000006.LICENSE
new file mode 100644
index 0000000..22efd0c
--- /dev/null
+++ b/node_modules/@sveltejs/adapter-node/.f7fdfefb7bf77fb4-00000006.LICENSE
@@ -0,0 +1,7 @@
+Copyright (c) 2020 [these people](https://github.com/sveltejs/kit/graphs/contributors)
+
+Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
\ No newline at end of file
diff --git a/node_modules/@sveltejs/adapter-node/files/handler.js b/node_modules/@sveltejs/adapter-node/files/handler.js
index 9d6f205..40d5245 100644
--- a/node_modules/@sveltejs/adapter-node/files/handler.js
+++ b/node_modules/@sveltejs/adapter-node/files/handler.js
@@ -1344,6 +1344,7 @@ const handler = sequence(
 	[
 		serve(path.join(dir, 'client'), true),
 		serve(path.join(dir, 'static')),
+		serve(path.join(dir, 'fallback'), true),
 		serve_prerendered(),
 		ssr
 	].filter(Boolean)
diff --git a/node_modules/@sveltejs/adapter-node/index.js b/node_modules/@sveltejs/adapter-node/index.js
index 9b0b315..b01fd74 100644
--- a/node_modules/@sveltejs/adapter-node/index.js
+++ b/node_modules/@sveltejs/adapter-node/index.js
@@ -4,6 +4,7 @@ import { rollup } from 'rollup';
 import { nodeResolve } from '@rollup/plugin-node-resolve';
 import commonjs from '@rollup/plugin-commonjs';
 import json from '@rollup/plugin-json';
+import path from "node:path"
 
 const files = fileURLToPath(new URL('./files', import.meta.url).href);
 
@@ -25,6 +26,10 @@ export default function (opts = {}) {
 			builder.writeClient(`${out}/client${builder.config.kit.paths.base}`);
 			builder.writePrerendered(`${out}/prerendered${builder.config.kit.paths.base}`);
 			
+			if (opts.fallback) {
+				builder.generateFallback(path.join(`${out}/fallback`, opts.fallback))
+			}
+
 			if (precompress) {
 				builder.log.minor('Compressing assets');
 				await Promise.all([
